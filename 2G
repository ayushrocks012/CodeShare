Option Explicit

' --- Windows API Declaration for OLE Message Filter ---
' Used to suppress Excel's "Server Busy" popups during SAP interaction
Private Declare PtrSafe Function CoRegisterMessageFilter Lib "OLE32.DLL" _
    (ByVal lpMessageFilter As LongPtr, ByRef lplpMessageFilter As LongPtr) As Long ' HRESULT return

' --- Windows API Declaration for Sleep Function ---
' Used for pauses during script execution
#If VBA7 Then ' Handles 64-bit Office versions
    Public Declare PtrSafe Sub Sleep Lib "kernel32" (ByVal dwMilliseconds As LongPtr)
#Else ' Handles 32-bit Office versions
    Public Declare Sub Sleep Lib "kernel32" (ByVal dwMilliseconds As Long)
#End If

' --- Global Objects required across calls ---
' These hold references to the SAP GUI objects once connected.
' *** USING EARLY BINDING - REQUIRES REFERENCE TO "SAP GUI Scripting API" Library ***
' (In VBA Editor: Tools -> References -> Check "SAP GUI Scripting API")
Public objGui       As GuiApplication ' SAP GUI Application object (main scripting interface)
Public objConn      As GuiConnection  ' SAP GUI Connection object (represents a connection to one system)
Public objSess      As GuiSession     ' SAP GUI Session object (represents a specific window/mode)
Public objSBar      As GuiStatusbar   ' SAP GUI Statusbar object (for reading messages)

' //========================================================================
' // Sub: StartMB51Extract
' // Purpose: Main entry point for the user. This sub orchestrates the process:
' //          1. Checks for an existing usable session.
' //          2. If none, finds an existing connection to the target system.
' //          3. If connection found, finds/creates a session (/o).
' //          4. If NO connection found, attempts SSO login.
' //          5. If session obtained, calls RunGUIScript to extract MB51.
' //========================================================================
Public Sub StartMB51Extract() ' <-- This is the macro you run from Excel (Alt+F8)

    ' --- CONFIGURATION CONSTANTS ---
    ' *** VITAL: Set ALL of these correctly for your environment ***

    ' 1. TARGET SYSTEM IDENTIFICATION (for FINDING existing sessions/connections)
    '    Format: System ID & Client (e.g., "PEA100", "P01100", "TST300")
    Const cTARGET_SYSTEM_ID_CLIENT As String = "PEA100" ' <<< ADJUST: Your Target System ID + Client

    ' 2. TARGET SYSTEM DESCRIPTION (for LOGGING IN via SSO if no connection exists)
    '    Format: The EXACT text description from your SAP Logon Pad entry configured for SSO/SNC
    Const cTARGET_SYSTEM_DESCRIPTION As String = "9A. Symphony ECC Production" ' <<< ADJUST: EXACT Description from SAP Logon Pad

    ' 3. SAP LOGON PATH (only used if GetObject fails and SSO login is attempted)
    '    Verify this path points to your saplogon.exe file.
    Const cSAP_LOGON_PATH As String = "C:\Program Files (x86)\SAP\FrontEnd\SAPgui\saplogon.exe" ' <<< VERIFY/ADJUST Path
    '    Common alternative: "C:\Program Files\SAP\FrontEnd\SAPgui\saplogon.exe"

    ' 4. SESSION & TIMEOUT SETTINGS
    Const cMAX_SESSIONS As Integer = 6          ' Maximum allowed SAP sessions per connection before /o fails
    Const cLOGON_TIMEOUT_SECONDS As Long = 60   ' Timeout (seconds) for waiting for session after SSO OpenConnection

    ' --- Local Variables ---
    Dim SapGuiAuto As Object          ' For GetObject("SAPGUI") - Use Object initially for flexibility
    Dim TargetConn As GuiConnection   ' Connection object for the target system
    Dim W_conn As GuiConnection       ' Loop variable for connections
    Dim W_Sess As GuiSession          ' Loop variable for sessions
    Dim FirstFoundSess As GuiSession  ' Stores first valid session found (used for /o fallback)
    Dim NewSess As GuiSession         ' Stores the newly created session via /o
    Dim SessionObtained As Boolean    ' Flag: True if a suitable session was found/created/logged into
    Dim Session_Nr_All As Long        ' Stores the number of sessions in the relevant connection
    Dim i As Long                     ' Loop counter for Connections
    Dim j As Long                     ' Loop counter for Sessions
    Dim highestSessNum As Long        ' To find the newest session after /o
    Dim currentSessNum As Long
    Dim MsgResult As VbMsgBoxResult   ' To store result from MsgBox calls
    Dim currentTransaction As String  ' To check if existing session is alive
    Dim foundConnection As Boolean    ' Flag: True if connection for target system found

    ' Enable central error handling for this setup phase
    On Error GoTo ErrorHandler

    ' Optimize Excel performance during script execution
    Application.ScreenUpdating = False
    Application.Calculation = xlCalculationManual

    ' Initialize state variables
    SessionObtained = False
    Session_Nr_All = 0
    foundConnection = False
    Set TargetConn = Nothing
    Set FirstFoundSess = Nothing

    ' Basic check: Ensure target system constants are set
    If Trim$(cTARGET_SYSTEM_ID_CLIENT) = "" Or Trim$(cTARGET_SYSTEM_DESCRIPTION) = "" Then
        MsgBox "Target SAP system constants (cTARGET_SYSTEM_ID_CLIENT and/or cTARGET_SYSTEM_DESCRIPTION) are not defined in the VBA code." & vbCrLf & _
               "Please edit the code and set these values.", vbCritical + vbOKOnly, "Configuration Error"
        GoTo Cleanup ' Exit gracefully
    End If
    Debug.Print "====================================================="
    Debug.Print Format(Now, "yyyy-mm-dd hh:nn:ss") & " - Starting MB51 Extract Process..."
    Debug.Print "Target System (ID+Client for Find): " & cTARGET_SYSTEM_ID_CLIENT
    Debug.Print "Target System (Description for SSO Login): " & cTARGET_SYSTEM_DESCRIPTION
    Debug.Print "-----------------------------------------------------"

    ' --- STEP 1: Check for existing valid global session ---
    ' If the script ran recently and objSess is still valid, reuse it.
    If Not objSess Is Nothing Then
        On Error Resume Next ' Check if session object is still valid (might have been closed)
        If objSess.Info.SystemName & objSess.Info.Client = cTARGET_SYSTEM_ID_CLIENT Then
            currentTransaction = objSess.Info.TRANSACTION ' Attempt to access a property to check validity
            If Err.Number = 0 Then
                ' Session is valid and for the correct system
                On Error GoTo ErrorHandler ' Restore normal error handling
                ' Ensure other global objects are also set
                If objConn Is Nothing Then Set objConn = objSess.Parent
                If objSBar Is Nothing Then Set objSBar = objSess.FindById("wnd[0]/sbar")
                SessionObtained = True
                Debug.Print Format(Now, "yyyy-mm-dd hh:nn:ss") & " - Reusing existing valid global session #" & objSess.Info.SessionNumber & " for " & cTARGET_SYSTEM_ID_CLIENT
                GoTo RunReportScript ' Proceed directly with the existing session
            Else
                ' Error occurred accessing the session, it's invalid
                Err.Clear
                On Error GoTo ErrorHandler
                Debug.Print Format(Now, "yyyy-mm-dd hh:nn:ss") & " - Existing global objSess for " & cTARGET_SYSTEM_ID_CLIENT & " is invalid/closed. Clearing global objects."
                Set objSess = Nothing: Set objConn = Nothing: Set objSBar = Nothing: Set objGui = Nothing ' Clear all globals if session died
            End If
        Else
             ' Global session exists but is for the wrong system
             Debug.Print Format(Now, "yyyy-mm-dd hh:nn:ss") & " - Existing global objSess is for system " & objSess.Info.SystemName & objSess.Info.Client & ", not target " & cTARGET_SYSTEM_ID_CLIENT & ". Clearing global objects."
             Set objSess = Nothing: Set objConn = Nothing: Set objSBar = Nothing: Set objGui = Nothing ' Clear all globals
        End If
        On Error GoTo ErrorHandler ' Restore main handler
    End If

    ' --- STEP 2: Get SAP GUI Scripting Engine ---
    ' Try GetObject first. If it fails, SAP Logon might not be running.
    ' We only attempt to *start* SAP Logon later if we need to perform an SSO login.
    If objGui Is Nothing Then
        On Error Resume Next ' Temporarily disable errors for GetObject
        Set SapGuiAuto = GetObject("SAPGUI")
        Dim getObjectErrNum As Long: getObjectErrNum = Err.Number ' Store potential error
        Err.Clear
        On Error GoTo ErrorHandler ' Restore main handler

        If getObjectErrNum = 0 And Not SapGuiAuto Is Nothing Then
            ' GetObject succeeded, now get the scripting engine
            Set objGui = SapGuiAuto.GetScriptingEngine ' Set global objGui
            If objGui Is Nothing Then
                ' This is unusual - GetObject worked but GetScriptingEngine failed.
                MsgBox "Could not get SAP GUI Scripting Engine even though GetObject('SAPGUI') succeeded." & vbCrLf & _
                       "Scripting might be disabled in SAP GUI options or by the server.", vbCritical, "Scripting Engine Error"
                GoTo Cleanup
            End If
            Debug.Print Format(Now, "yyyy-mm-dd hh:nn:ss") & " - Successfully obtained SAP GUI Scripting Engine via GetObject."
        Else
            ' GetObject failed. This is okay for now. objGui remains Nothing.
            ' If we later find no existing connection, the EstablishSsoConnection function will handle starting SAP Logon.
            Debug.Print Format(Now, "yyyy-mm-dd hh:nn:ss") & " - GetObject(""SAPGUI"") failed (Error: " & getObjectErrNum & "). SAP Logon might not be running."
            Set SapGuiAuto = Nothing ' Ensure it's Nothing if GetObject failed
        End If
    End If

    ' --- STEP 3: Find Existing Connection matching Target System (ID+Client) ---
    ' Only proceed if we successfully obtained the objGui object in Step 2.
    If Not objGui Is Nothing Then
        Debug.Print Format(Now, "yyyy-mm-dd hh:nn:ss") & " - Searching for existing connection to system: " & cTARGET_SYSTEM_ID_CLIENT
        foundConnection = False ' Reset flag before loop
        For i = 0 To objGui.Children.Count - 1 ' Loop through all connections
            Set W_conn = objGui.Children(CLng(i))
            If Not W_conn Is Nothing Then
                ' Check connection based on the SystemName & Client of its first session (more reliable than Description sometimes)
                 If W_conn.Children.Count > 0 Then ' Connection must have at least one session
                     Set W_Sess = W_conn.Children(0) ' Get the first session of this connection
                     If Not W_Sess Is Nothing Then
                         On Error Resume Next ' Info properties might fail temporarily if session is busy/closing
                         Dim sysInfoCheck As String: sysInfoCheck = W_Sess.Info.SystemName & W_Sess.Info.Client
                         Dim infoErr As Long: infoErr = Err.Number
                         Err.Clear
                         On Error GoTo ErrorHandler ' Restore main handler

                         If infoErr = 0 And sysInfoCheck = cTARGET_SYSTEM_ID_CLIENT Then
                             ' Found a connection whose first session matches our target system
                             Set TargetConn = W_conn
                             foundConnection = True
                             Debug.Print Format(Now, "yyyy-mm-dd hh:nn:ss") & " - Found existing connection object for " & cTARGET_SYSTEM_ID_CLIENT & " (Description: '" & TargetConn.Description & "')"
                             Exit For ' Exit connection loop, we found our target
                         End If
                         Set W_Sess = Nothing ' Release temp session handle
                     End If
                 End If
            End If
             Set W_conn = Nothing ' Release temp connection handle
        Next i
    Else
        Debug.Print Format(Now, "yyyy-mm-dd hh:nn:ss") & " - SAP GUI object (objGui) not available, cannot search for existing connections."
        ' The flow will proceed to attempt SSO login if objGui is Nothing
    End If


    ' --- STEP 4: Handle Based on Connection Found Status ---

    If foundConnection And Not TargetConn Is Nothing Then
        ' --- PATH A: Connection Found - Try to find an existing idle session or create a new one via /o ---
        Debug.Print Format(Now, "yyyy-mm-dd hh:nn:ss") & " - Path A: Existing connection found. Checking sessions..."
        Set objConn = TargetConn ' Set global connection object
        Session_Nr_All = objConn.Children.Count
        Debug.Print Format(Now, "yyyy-mm-dd hh:nn:ss") & " - Checking " & Session_Nr_All & " existing session(s) on connection for " & cTARGET_SYSTEM_ID_CLIENT & "..."

        ' --- Check for an IDLE session ---
        Set FirstFoundSess = Nothing ' Reset helper
        For j = 0 To objConn.Children.Count - 1
            Set W_Sess = objConn.Children(CLng(j))
            If Not W_Sess Is Nothing Then
                ' Store the first valid session we encounter, in case we need it for /o later
                If FirstFoundSess Is Nothing Then Set FirstFoundSess = W_Sess

                ' Check if the session is idle (at main menu or session manager)
                On Error Resume Next ' Check transaction code, might fail if session is locked/closing
                Dim idleCheckTCode As String: idleCheckTCode = W_Sess.Info.TRANSACTION
                Dim idleErr As Long: idleErr = Err.Number
                Err.Clear
                On Error GoTo ErrorHandler ' Restore main handler

                If idleErr = 0 Then ' Successfully read transaction code
                    Select Case UCase(idleCheckTCode) ' Use UCase for robust comparison
                        Case "SESSION_MANAGER", "SMEN", "S000" ' Common idle transaction codes
                            ' Found an idle session!
                            Set objSess = W_Sess ' Set global session
                            On Error Resume Next ' Status bar might fail temporarily
                            Set objSBar = objSess.FindById("wnd[0]/sbar") ' Set global status bar
                            If objSBar Is Nothing Then Debug.Print "Warning: Could not get status bar for idle session #" & objSess.Info.SessionNumber
                            On Error GoTo ErrorHandler
                            SessionObtained = True
                            Debug.Print Format(Now, "yyyy-mm-dd hh:nn:ss") & " - Found suitable idle session #" & objSess.Info.SessionNumber & " (TCode: " & idleCheckTCode & ")"
                            GoTo RunReportScript ' Found one, proceed to run the report
                    End Select
                Else
                    Debug.Print Format(Now, "yyyy-mm-dd hh:nn:ss") & " - Could not get transaction code for session #" & j + 1 & " (Error: " & idleErr & "). Skipping idle check for this session."
                End If
            End If
            Set W_Sess = Nothing ' Release temp session object for this loop iteration
        Next j

        ' --- No idle session found, try to CREATE a new one using /o ---
        If Not SessionObtained Then
            Debug.Print Format(Now, "yyyy-mm-dd hh:nn:ss") & " - No idle session found for " & cTARGET_SYSTEM_ID_CLIENT & "."
            If FirstFoundSess Is Nothing Then
                ' This should be rare if foundConnection was True, means we couldn't even access the first session
                MsgBox "No sessions could be accessed at all for system " & cTARGET_SYSTEM_ID_CLIENT & " on the identified connection, even though the connection was found." & vbCrLf & _
                       "Please check the state of your SAP sessions.", vbCritical, "Session Access Error"
                GoTo Cleanup
            End If

            ' Check if we are below the maximum session limit
            If Session_Nr_All < cMAX_SESSIONS Then
                 Debug.Print Format(Now, "yyyy-mm-dd hh:nn:ss") & " - Session limit (" & cMAX_SESSIONS & ") not reached (" & Session_Nr_All & " open). Attempting to create new session using /o in session #" & FirstFoundSess.Info.SessionNumber & "..."
                 On Error GoTo ErrorHandler ' Use main error handler for /o process

                 ' Use the first found session to initiate /o
                 Set objSess = FirstFoundSess ' Temporarily use this session for /o command
                 ' Ensure the main window (wnd[0]) is active and ready
                 If objSess.ActiveWindow.Name <> "wnd[0]" Then
                     MsgBox "The main window (wnd[0]) of session #" & objSess.Info.SessionNumber & " needed to execute /o is not active or accessible." & vbCrLf & _
                            "Please bring it to the front or ensure it's not busy/locked.", vbExclamation, "Action Required for /o"
                     Set objSess = Nothing ' Clear temp assignment
                     GoTo Cleanup
                 End If

                 ' Execute /o command
                 objSess.FindById("wnd[0]/tbar[0]/okcd").Text = "/o" ' Enter /o in command field
                 objSess.FindById("wnd[0]").sendVKey 0             ' Press Enter
                 Set objSess = Nothing ' Clear temp assignment, we need to find the NEW session next

                 Debug.Print Format(Now, "yyyy-mm-dd hh:nn:ss") & " - /o entered. Waiting for potential session overview popup (wnd[1])..."
                 Sleep 1000 ' Wait a moment for SAP to react

                 ' Handle the "Create Session" popup (wnd[1]) if it appears (depends on SAP version/settings)
                 Dim popupWnd As GuiModalWindow
                 On Error Resume Next ' Ignore error if wnd[1] not found immediately
                 ' Check the active session associated with the GUI object for the popup
                 Set popupWnd = objGui.ActiveSession.FindById("wnd[1]", False) ' False = Don't raise error if not found
                 On Error GoTo ErrorHandler ' Restore main handler

                 If Not popupWnd Is Nothing Then
                    ' Popup detected, press the "Generate" button (usually btn[5])
                    Debug.Print Format(Now, "yyyy-mm-dd hh:nn:ss") & " - Session overview popup (wnd[1]) found. Attempting to press Generate..."
                    Const GENERATE_BUTTON_ID As String = "wnd[1]/tbar[0]/btn[5]" ' <<< Verify this ID if /o fails
                    On Error Resume Next ' Try pressing the button
                    popupWnd.FindById(GENERATE_BUTTON_ID).press
                    If Err.Number <> 0 Then
                        Debug.Print Format(Now, "yyyy-mm-dd hh:nn:ss") & " - Failed to press Generate button " & GENERATE_BUTTON_ID & ". Error: " & Err.Description
                        Err.Clear
                        Debug.Print Format(Now, "yyyy-mm-dd hh:nn:ss") & " - Attempting VKey 0 (Enter) on popup instead..."
                        popupWnd.sendVKey 0 ' Try sending Enter as fallback
                    Else
                        Debug.Print Format(Now, "yyyy-mm-dd hh:nn:ss") & " - Generate button pressed."
                    End If
                    On Error GoTo ErrorHandler ' Restore main handler
                    Sleep 2000 ' Wait a bit longer after popup interaction for new session to initialize
                 Else
                    ' No popup detected, new session might open directly
                    Debug.Print Format(Now, "yyyy-mm-dd hh:nn:ss") & " - Session overview popup (wnd[1]) not detected, proceeding to find new session."
                    Sleep 1000 ' Shorter wait if no popup
                 End If
                 Set popupWnd = Nothing ' Release popup object

                 ' Find the newly created session (usually the one with the highest session number)
                 highestSessNum = 0
                 Set NewSess = Nothing
                 For j = 0 To objConn.Children.Count - 1 ' Re-check sessions on the *same connection*
                     Set W_Sess = objConn.Children(CLng(j))
                     If Not W_Sess Is Nothing Then
                         On Error Resume Next ' Session number read might fail briefly
                         currentSessNum = W_Sess.Info.SessionNumber
                         If Err.Number = 0 Then
                            If currentSessNum > highestSessNum Then
                                highestSessNum = currentSessNum
                                Set NewSess = W_Sess ' Store the session with the highest number found so far
                            End If
                         Else
                            Debug.Print "Warning: Could not read session number for session index " & j & " while finding new session."
                            Err.Clear
                         End If
                         On Error GoTo ErrorHandler
                     End If
                     ' Don't release W_Sess here if it might be the NewSess we want
                 Next j

                 If NewSess Is Nothing Then
                     Err.Raise vbObjectError + 521, "StartMB51Extract", "Could not identify the newly created session after using /o. Check SAP state."
                 End If

                 ' Successfully found the new session, set global objects
                 Set objSess = NewSess
                 Debug.Print Format(Now, "yyyy-mm-dd hh:nn:ss") & " - Successfully identified new session #" & objSess.Info.SessionNumber & " created via /o."
                 On Error Resume Next ' Status bar might not be ready immediately
                 Set objSBar = objSess.FindById("wnd[0]/sbar")
                 If objSBar Is Nothing Then Debug.Print "Warning: Could not get status bar for new session immediately."
                 On Error GoTo ErrorHandler
                 SessionObtained = True
                 Debug.Print Format(Now, "yyyy-mm-dd hh:nn:ss") & " - Proceeding with newly created session."
                 GoTo RunReportScript ' Proceed to run the report

            Else
                ' Max sessions reached, cannot create a new one via /o
                 MsgResult = MsgBox("Maximum number of sessions (" & Session_Nr_All & "/" & cMAX_SESSIONS & ") already open for system " & cTARGET_SYSTEM_ID_CLIENT & "." & vbCrLf & _
                                     "No idle session was found, and no new session can be created via /o." & vbCrLf & vbCrLf & _
                                     "Please close an existing session manually if you need to proceed.", vbCritical + vbOKOnly, "Session Limit Reached")
                 GoTo Cleanup
            End If
        End If ' End of /o logic (if no idle session was found)

    Else
        ' --- PATH B: No Connection Found (or objGui was Nothing) - Attempt SSO Logon ---
        Debug.Print Format(Now, "yyyy-mm-dd hh:nn:ss") & " - Path B: No existing connection found for " & cTARGET_SYSTEM_ID_CLIENT & " (or SAP GUI object not initially found)."
        Debug.Print Format(Now, "yyyy-mm-dd hh:nn:ss") & " - Attempting new connection via SSO using description: '" & cTARGET_SYSTEM_DESCRIPTION & "'"

        ' Call the dedicated SSO connection function
        SessionObtained = EstablishSsoConnection(cTARGET_SYSTEM_DESCRIPTION, cLOGON_TIMEOUT_SECONDS, cSAP_LOGON_PATH)

        If SessionObtained Then
            Debug.Print Format(Now, "yyyy-mm-dd hh:nn:ss") & " - SSO connection function reported success."
             ' Optional but recommended: Verify the logged-in system matches the intended ID+Client
             If Not objSess Is Nothing Then
                On Error Resume Next
                Dim loggedInSys As String: loggedInSys = objSess.Info.SystemName & objSess.Info.Client
                Dim sysCheckErr As Long: sysCheckErr = Err.Number
                Err.Clear
                On Error GoTo ErrorHandler
                If sysCheckErr = 0 Then
                    If loggedInSys <> cTARGET_SYSTEM_ID_CLIENT Then
                         MsgBox "Warning: Successfully logged in via SSO using description '" & cTARGET_SYSTEM_DESCRIPTION & "', " & _
                                "but the resulting system is '" & loggedInSys & "', which does not match the expected Find criteria '" & cTARGET_SYSTEM_ID_CLIENT & "'. " & vbCrLf & vbCrLf & _
                                "The script will continue, but please check your SAP Logon Pad configuration and VBA constants (cTARGET_SYSTEM_ID_CLIENT vs cTARGET_SYSTEM_DESCRIPTION).", vbExclamation, "System Mismatch Warning"
                         ' Decide whether to continue or exit based on mismatch severity
                         ' GoTo Cleanup ' Uncomment this line to stop the script if the systems don't match
                    Else
                        Debug.Print Format(Now, "yyyy-mm-dd hh:nn:ss") & " - SSO login successful and resulting system (" & loggedInSys & ") matches target (" & cTARGET_SYSTEM_ID_CLIENT & ")."
                    End If
                Else
                    Debug.Print Format(Now, "yyyy-mm-dd hh:nn:ss") & " - Warning: Could not verify SystemID+Client after SSO login. Error reading session info: " & sysCheckErr
                End If
             End If
             GoTo RunReportScript ' Proceed to run the report script
        Else
            ' EstablishSsoConnection function failed (it should have shown its own error message)
            Debug.Print Format(Now, "yyyy-mm-dd hh:nn:ss") & " - EstablishSsoConnection function failed. Exiting."
            GoTo Cleanup ' Exit the main sub
        End If
    End If ' End of Path A (Connection Found) vs Path B (No Connection Found / SSO Attempt)


    ' --- Fallback Check: Should ideally not be reached if logic above is correct ---
    If Not SessionObtained Then
        MsgBox "Could not find, create, or log into a suitable session for system " & cTARGET_SYSTEM_ID_CLIENT & " after all attempts. Unknown final state.", vbCritical, "Session Error - Fallback"
        GoTo Cleanup
    End If


RunReportScript:
    ' If we reached here via GoTo, SessionObtained should be True and objSess should be valid
    If SessionObtained And Not objSess Is Nothing Then
        Debug.Print "-----------------------------------------------------"
        Debug.Print Format(Now, "yyyy-mm-dd hh:nn:ss") & " - Session ready (ID: " & objSess.Info.SessionNumber & "). Proceeding to run MB51 script..."
        Debug.Print "-----------------------------------------------------"
        ' *** Call the subroutine that contains the actual SAP transaction steps ***
        RunGUIScript
    Else
        ' This indicates an internal logic error if SessionObtained is True but objSess is Nothing
        MsgBox "Internal Error: Could not proceed to run the GUI script. Session object is not valid or session was not obtained correctly.", vbCritical, "Internal Logic Error"
    End If

Cleanup:
    ' Restore Excel settings and release local objects
    Debug.Print "-----------------------------------------------------"
    Debug.Print Format(Now, "yyyy-mm-dd hh:nn:ss") & " - Running Cleanup for StartMB51Extract..."

    ' Restore Excel environment
    Application.Calculation = xlCalculationAutomatic
    Application.ScreenUpdating = True

    ' Release local object variables used within this sub
    Set TargetConn = Nothing
    Set W_conn = Nothing
    Set W_Sess = Nothing
    Set FirstFoundSess = Nothing
    Set NewSess = Nothing
    Set SapGuiAuto = Nothing ' Release the initial GetObject handle if it was used

    ' *** IMPORTANT: Decide whether to release GLOBAL SAP objects ***
    ' Releasing them means the next run starts completely fresh.
    ' Keeping them allows reusing the connection/session if the script is run again soon.
    ' Comment out the block below if you want to KEEP the global objects for potential reuse.
    ' --------------------------------------------------
'    Debug.Print Format(Now, "yyyy-mm-dd hh:nn:ss") & " - Releasing global SAP objects..."
'    On Error Resume Next ' Ignore errors if objects are already nothing or invalid
'    Set objSBar = Nothing
'    Set objSess = Nothing
'    Set objConn = Nothing
'    Set objGui = Nothing
'    On Error GoTo 0 ' Restore default error handling
'    Debug.Print Format(Now, "yyyy-mm-dd hh:nn:ss") & " - Global SAP objects released."
    ' --------------------------------------------------

    Debug.Print Format(Now, "yyyy-mm-dd hh:nn:ss") & " - StartMB51Extract finished."
    Debug.Print "====================================================="
    Exit Sub ' Ensure normal exit

ErrorHandler:
    ' General error handler for session setup/creation/login phase in StartMB51Extract
    MsgBox "An error occurred during SAP session setup, creation, or login (in StartMB51Extract):" & vbCrLf & vbCrLf & _
           "Error Number: " & Err.Number & vbCrLf & _
           "Description: " & Err.Description & vbCrLf & _
           "Source: " & Err.Source & vbCrLf & vbCrLf & _
           "The script will now clean up. Please check SAP status and Debug Window (Ctrl+G in VBA editor) for details.", _
           vbCritical, "SAP Connection/Session Error"
    ' Go to cleanup section after showing the error
    Resume Cleanup

End Sub


' //========================================================================
' // Function: EstablishSsoConnection
' // Purpose: Attempts to connect to a specified SAP system using OpenConnection by Description,
' //          assuming SSO/SNC handles the authentication based on SAP Logon Pad settings.
' //          Attempts to start SAP Logon Pad if not running.
' //          Sets global objects objGui, objConn, objSess, objSBar upon success.
' // Arguments:
' //      systemDescription: The exact description string from SAP Logon Pad.
' //      logonTimeout: Maximum seconds to wait for the session to become active.
' //      sapLogonPath: Full path to saplogon.exe.
' // Returns: True if connection successful and session obtained, False otherwise.
' //========================================================================
Private Function EstablishSsoConnection(ByVal systemDescription As String, ByVal logonTimeout As Long, ByVal sapLogonPath As String) As Boolean
    ' Local variables specific to this function
    Dim SapGuiAuto As Object ' Late binding for GetObject initially
    Dim TargetConn As GuiConnection
    Dim TargetSess As GuiSession
    Dim attempts As Integer
    Dim startTime As Single

    ' Enable local error handling for this function
    On Error GoTo SsoErrorHandler

    EstablishSsoConnection = False ' Default to failure

    ' --- Reset relevant Global Objects before attempting new login ---
    ' We are initiating a *new* connection attempt here.
    Set objConn = Nothing
    Set objSess = Nothing
    Set objSBar = Nothing
    ' objGui might already be set if GetObject succeeded earlier, but check again if needed.

    Debug.Print Format(Now, "yyyy-mm-dd hh:nn:ss") & " - Entering EstablishSsoConnection function..."

    ' --- Step 1: Get/Ensure SAP GUI Scripting Engine ---
    ' Check if objGui is already valid from the main sub. If not, try GetObject/Start Logon here.
    If objGui Is Nothing Then
        Debug.Print Format(Now, "yyyy-mm-dd hh:nn:ss") & " - objGui is Nothing, attempting GetObject/Start Logon..."
        ' Try GetObject again specifically for this SSO path
        On Error Resume Next ' Temporarily disable errors
        Set SapGuiAuto = GetObject("SAPGUI")
        Dim getObjErr As Long: getObjErr = Err.Number
        Err.Clear ' Clear potential GetObject error
        On Error GoTo SsoErrorHandler ' Restore local handler

        If getObjErr <> 0 Or SapGuiAuto Is Nothing Then
             ' GetObject failed, SAP Logon is likely not running. Attempt to start it.
             Debug.Print Format(Now, "yyyy-mm-dd hh:nn:ss") & " - GetObject(""SAPGUI"") failed within EstablishSsoConnection. Attempting to start SAP Logon Pad: " & sapLogonPath
             ' Attempt to start SAP Logon Pad using Shell
             Dim shellResult As Variant
             On Error Resume Next ' Handle error if Shell command fails (e.g., path incorrect, permissions)
             shellResult = Shell(sapLogonPath, vbNormalFocus)
             Dim shellErr As Long: shellErr = Err.Number
             Dim shellDesc As String: shellDesc = Err.Description
             Err.Clear ' Clear potential Shell error
             On Error GoTo SsoErrorHandler ' Restore local handler

             If shellErr <> 0 Then
                 ' Failed to start SAP Logon via Shell
                 MsgBox "Failed to start SAP Logon Pad using Shell command." & vbCrLf & vbCrLf & _
                        "Error (" & shellErr & "): " & shellDesc & vbCrLf & _
                        "Please verify the cSAP_LOGON_PATH constant in the VBA code: " & vbCrLf & sapLogonPath, vbCritical, "Shell Command Error"
                 GoTo SsoCleanup ' Exit function on shell failure
             End If

             ' Shell command executed, wait for SAP Logon Pad to initialize
             Debug.Print Format(Now, "yyyy-mm-dd hh:nn:ss") & " - Shell command executed. Waiting 5 seconds for SAP Logon Pad to initialize..."
             Sleep 5000 ' Wait 5 seconds

             ' Try GetObject again repeatedly after starting SAP Logon
             attempts = 0
             Do
                 attempts = attempts + 1
                 Debug.Print Format(Now, "yyyy-mm-dd hh:nn:ss") & " - Attempting GetObject(""SAPGUI"") after start (Attempt " & attempts & ")..."
                 On Error Resume Next ' Check GetObject again
                 Set SapGuiAuto = GetObject("SAPGUI")
                 If Err.Number = 0 And Not SapGuiAuto Is Nothing Then
                     Debug.Print Format(Now, "yyyy-mm-dd hh:nn:ss") & " - GetObject(""SAPGUI"") successful after starting SAP Logon."
                     Exit Do ' Success! Found the SAPGUI object
                 End If
                 Err.Clear ' Clear GetObject error for retry
                 Sleep 2000 ' Wait 2 more seconds before retrying
             Loop While attempts < 5 ' Try up to 5 times (total wait ~15 sec after shell)

             ' Check if GetObject succeeded after multiple attempts
             If SapGuiAuto Is Nothing Then
                  MsgBox "SAP Logon Pad was started, but GetObject(""SAPGUI"") still failed after multiple attempts." & vbCrLf & _
                         "Scripting might be disabled, SAP GUI may have issues, or it took too long to initialize.", vbCritical, "Prerequisite Error - GetObject Failed"
                  GoTo SsoCleanup ' Exit function
             End If
             ' If we get here, SapGuiAuto is valid after starting SAP Logon.
        Else
            ' GetObject succeeded on the first try within this function
            Debug.Print Format(Now, "yyyy-mm-dd hh:nn:ss") & " - GetObject(""SAPGUI"") succeeded within EstablishSsoConnection."
        End If ' End GetObject failure handling

        ' Now we should have a valid SapGuiAuto object (either from first try or after starting Logon)
        ' Get the Scripting Engine and assign it to the global objGui
        Set objGui = SapGuiAuto.GetScriptingEngine ' Set global objGui
        If objGui Is Nothing Then
            MsgBox "Could not get SAP GUI Scripting Engine. Ensure scripting is enabled in SAP GUI options and on the server.", vbCritical, "Scripting Engine Error"
            GoTo SsoCleanup ' Exit function
        End If
        Debug.Print Format(Now, "yyyy-mm-dd hh:nn:ss") & " - Successfully obtained SAP GUI Scripting Engine and set global objGui."
    Else
         ' objGui was already valid when this function was called
         Debug.Print Format(Now, "yyyy-mm-dd hh:nn:ss") & " - Using existing global objGui object for SSO connection."
    End If ' End objGui check


    ' --- Step 2: Open Connection using Description (Triggers SSO/SNC) ---
    Debug.Print Format(Now, "yyyy-mm-dd hh:nn:ss") & " - Attempting objGui.OpenConnection(""" & systemDescription & """, True)..."
    On Error Resume Next ' Handle errors specifically during connection opening
    Set TargetConn = objGui.OpenConnection(systemDescription, True) ' True = Open synchronously (waits for connection attempt to start)
    Dim openConnErr As Long: openConnErr = Err.Number
    Dim openConnDesc As String: openConnDesc = Err.Description
    Err.Clear ' Clear potential OpenConnection error
    On Error GoTo SsoErrorHandler ' Restore local error handling

    If openConnErr <> 0 Or TargetConn Is Nothing Then
        ' OpenConnection failed
        MsgBox "SSO Auto-Logon failed: Could not open connection using description '" & systemDescription & "'." & vbCrLf & vbCrLf & _
               "Error (" & openConnErr & "): " & openConnDesc & vbCrLf & vbCrLf & _
               "Please check:" & vbCrLf & _
               "- The System Description in VBA constant (cTARGET_SYSTEM_DESCRIPTION) EXACTLY matches SAP Logon Pad." & vbCrLf & _
               "- SAP Logon Pad entry for this description is configured correctly for SNC/SSO." & vbCrLf & _
               "- Your SSO credentials (e.g., Kerberos ticket, SNC certificate) are valid and accessible.", vbCritical, "SSO Connection Error"
        GoTo SsoCleanup ' Exit function
    End If

    ' OpenConnection succeeded, set the global connection object
    Set objConn = TargetConn
    Debug.Print Format(Now, "yyyy-mm-dd hh:nn:ss") & " - OpenConnection successful. Connection Description: '" & objConn.Description & "'"

    ' --- Step 3: Get Session created by SSO/SNC ---
    ' Wait for the session object (child of the connection) to appear.
    Debug.Print Format(Now, "yyyy-mm-dd hh:nn:ss") & " - Waiting for session object to appear..."
    startTime = Timer
    Do
        If objConn.Children.Count > 0 Then Exit Do ' Session object exists
        Sleep 500 ' Wait 0.5 seconds
        DoEvents ' Allow other processes
        If Timer - startTime > 15 Then ' Timeout for session object appearing (e.g., 15 secs)
             MsgBox "SSO Auto-Logon failed: Connection opened, but no session object appeared within 15 seconds." & vbCrLf & _
                    "SSO might have failed silently, is disabled for scripting, or encountered an unexpected initial screen.", vbCritical, "SSO Session Object Error"
             GoTo SsoCleanup ' Exit function
        End If
        ' Debug.Print "..." ' Optional: uncomment for verbose waiting dots
    Loop

    ' Get the first session object
    Set TargetSess = objConn.Children(0)
    If TargetSess Is Nothing Then
         MsgBox "SSO Auto-Logon failed: Could not get session object even though connection Children count > 0.", vbCritical, "SSO Session Object Error"
         GoTo SsoCleanup ' Exit function
    End If

    ' Set the global session object
    Set objSess = TargetSess
    Debug.Print Format(Now, "yyyy-mm-dd hh:nn:ss") & " - Session object obtained (Session Number: " & objSess.Info.SessionNumber & "). Waiting for it to become active..."

    ' --- Step 4: Wait for Session to be Ready (e.g., reach Main Menu) ---
    ' Check the transaction code to see if logon is complete.
    Debug.Print Format(Now, "yyyy-mm-dd hh:nn:ss") & " - Waiting for session to become ready (Timeout: " & logonTimeout & "s)..."
    startTime = Timer
    Do
        On Error Resume Next ' Info property might fail if session not fully ready or closes unexpectedly
        Dim currentTCode As String: currentTCode = objSess.Info.TRANSACTION
        Dim sessReadyErr As Long: sessReadyErr = Err.Number
        Err.Clear ' Clear potential Info error
        On Error GoTo SsoErrorHandler ' Restore local handler

        If sessReadyErr = 0 Then
            ' Successfully read transaction code
            If currentTCode <> "" And UCase(currentTCode) <> "SAPMSYST" Then ' Check if not empty and not the initial system screen
                Debug.Print Format(Now, "yyyy-mm-dd hh:nn:ss") & " - Session active. Current Transaction: " & currentTCode
                Exit Do ' Logon likely complete, exit wait loop
            End If
        Else
            ' Error reading Info property, session might be busy or closing
            Debug.Print Format(Now, "yyyy-mm-dd hh:nn:ss") & " - Waiting for session ready (Info error: " & sessReadyErr & ")" ' Log errors during wait
        End If

        Sleep 500 ' Wait 0.5 seconds
        DoEvents ' Allow other processes
        ' Check timeout
        If Timer - startTime > logonTimeout Then
            MsgBox "SSO Auto-Logon failed: Timeout (" & logonTimeout & "s) waiting for SAP main menu (or non-initial transaction) after opening connection." & vbCrLf & _
                   "SSO/SNC might have failed, be slow, or encountered an unexpected screen (e.g., system message popup).", vbCritical, "SSO Logon Timeout"
            GoTo SsoCleanup ' Exit function
        End If
    Loop

    ' --- Step 5: Get Status Bar ---
    ' Try to get the status bar object for the new session
    On Error Resume Next ' Status bar might not be immediately available
    Set objSBar = objSess.FindById("wnd[0]/sbar")
    If objSBar Is Nothing Then Debug.Print Format(Now, "yyyy-mm-dd hh:nn:ss") & " - Warning: Could not get status bar object immediately after SSO login."
    On Error GoTo SsoErrorHandler ' Restore local handler

    ' --- Success ---
    EstablishSsoConnection = True ' Set return value to True
    Debug.Print Format(Now, "yyyy-mm-dd hh:nn:ss") & " - Successfully connected and logged into SAP system '" & systemDescription & "' via SSO/SNC."
    GoTo SsoCleanup ' Go to cleanup, skipping error message

SsoErrorHandler:
    ' Error handler specific to this function
    MsgBox "An error occurred during the SAP SSO Logon attempt (within EstablishSsoConnection function):" & vbCrLf & vbCrLf & _
           "Error Number: " & Err.Number & vbCrLf & _
           "Description: " & Err.Description & vbCrLf & _
           "Source: " & Err.Source, vbCritical, "SSO Logon Function Error"
    ' Ensure function returns False on error
    EstablishSsoConnection = False
    ' Fall through to cleanup

SsoCleanup:
    ' Release local objects specific to this function
    Set SapGuiAuto = Nothing
    Set TargetConn = Nothing
    Set TargetSess = Nothing
    Debug.Print Format(Now, "yyyy-mm-dd hh:nn:ss") & " - Exiting EstablishSsoConnection function (Result: " & EstablishSsoConnection & ")."
    ' Note: Global objects (objGui, objConn, objSess, objSBar) are intentionally *not* cleared here.
    ' They are set by the function on success and needed by the calling procedure (StartMB51Extract).
End Function


' //========================================================================
' // Sub: RunGUIScript (MB51 Extraction Logic)
' // Purpose: Executes the specific steps for transaction MB51: enters criteria,
' //          executes, waits for results, handles popups, exports data.
' //          Relies on global objSess and objSBar being set correctly before being called.
' //========================================================================
Private Sub RunGUIScript() ' <-- Remains Private, called only by StartMB51Extract

    ' --- Constants specific to MB51 Execution ---
     Const cTRANSACTION As String = "mb51"                                    ' Target Transaction Code
     Const cPLANT As String = "1534"                                          ' <<< ADJUST: Your Plant Code
     Const cDATE_LOW As String = "01.03.2025"                                 ' <<< ADJUST: Start Date (DD.MM.YYYY format expected by SAP)
     Const cDATE_HIGH As String = "31.03.2025"                                ' <<< ADJUST: End Date (DD.MM.YYYY format expected by SAP)
     Const cLAYOUT As String = "AYUSH_TRY"                                    ' <<< ADJUST: Your ALV Layout Variant (leave "" for default/no layout)
     Const cDOWNLOAD_PATH As String = "Z:\Demand\Demand Review\SAP H2H Report" ' <<< ADJUST: Ensure this folder EXISTS and is WRITABLE
     Const cFILENAME_PREFIX As String = "MB51 Report"                         ' Prefix for the output filename
     Const cFILENAME_EXTENSION As String = ".XLSX"                            ' Desired file extension (should match export format, &XXL usually -> XLSX)
     Const cREPORT_EXEC_TIMEOUT_SECONDS As Long = 900                         ' Max seconds to wait for report execution (Busy flag/Status Bar) (15 min)
     Const cGRID_WAIT_TIMEOUT_SECONDS As Long = 180                           ' Max seconds to wait specifically for the results grid control to appear (3 min)
     Const cGRID_ID As String = "wnd[0]/usr/cntlGRID1/shellcont/shell"        ' Standard technical ID of the ALV grid control in MB51 results

    ' --- Status Bar Messages for Completion Check ---
    ' These messages indicate the report processing is finishing, just before the grid appears. Adjust if needed based on your system.
     Const cSTATUS_MSG_COMPLETE_1 As String = "Prepare List Output"  ' <<< ADJUST if your system shows a different final message
     Const cSTATUS_MSG_COMPLETE_2 As String = ""                     ' Add more messages if needed
     Const cSTATUS_MSG_COMPLETE_3 As String = ""                     ' Add more messages if needed

    ' --- Local Variables for RunGUIScript ---
    Dim formattedDateLow As String      ' For filename generation
    Dim formattedDateHigh As String     ' For filename generation
    Dim formattedTimestamp As String    ' For filename generation
    Dim dynamicFilename As String       ' Full path and filename for export
    Dim startTime As Single             ' For timeout checks
    Dim success As Boolean              ' Flag for export sequence success
    Dim gridObject As GuiShell          ' Object representing the results grid (ALV)
    Dim currentStatus As String         ' To store status bar text

    ' --- Variables for OLE Message Filter ---
    Dim lMsgFilter As LongPtr           ' Holds the pointer to our dummy filter (0)
    Dim lPreviousFilter As LongPtr      ' Holds the pointer to the original Excel filter
    Dim hResult As Long                 ' To check the result of CoRegisterMessageFilter API call

    ' --- Enable Central Error Handling for this Sub ---
    ' Jumps to RestoreFilterAndErrorHandler on any runtime error within this sub
    On Error GoTo RestoreFilterAndErrorHandler

    ' --- Pre-checks: Ensure global SAP objects are valid ---
    If objSess Is Nothing Then
        ' This should not happen if StartMB51Extract worked correctly
        Err.Raise vbObjectError + 510, "RunGUIScript", "SAP Session object (objSess) is not valid at the start of RunGUIScript."
    End If
    ' Try to ensure status bar object is available
    If objSBar Is Nothing Then
        On Error Resume Next ' Try to get it again
        Set objSBar = objSess.FindById("wnd[0]/sbar")
        On Error GoTo RestoreFilterAndErrorHandler ' Restore main handler
        If objSBar Is Nothing Then
             Debug.Print Format(Now, "yyyy-mm-dd hh:nn:ss") & " - Warning: Status bar object (objSBar) could not be obtained in RunGUIScript."
             ' Script can continue but status bar checks might fail.
        End If
    End If
    Debug.Print Format(Now, "yyyy-mm-dd hh:nn:ss") & " - RunGUIScript started. Session validated."

    ' --- Step 1: Prepare Dynamic Filename ---
    ' Creates a unique filename based on dates and current timestamp
     On Error Resume Next ' Allow errors during date parsing in case format is wrong
     ' Assumes input dates are DD.MM.YYYY, converts to YYYYMMDD for filename
     formattedDateLow = Right$(cDATE_LOW, 4) & Mid$(cDATE_LOW, 4, 2) & Left$(cDATE_LOW, 2)
     formattedDateHigh = Right$(cDATE_HIGH, 4) & Mid$(cDATE_HIGH, 4, 2) & Left$(cDATE_HIGH, 2)
     If Err.Number <> 0 Then
         ' Handle potential errors if date constants are not in DD.MM.YYYY format
         MsgBox "Could not parse dates (" & cDATE_LOW & ", " & cDATE_HIGH & ") for filename." & vbCrLf & _
                "Please ensure they are in DD.MM.YYYY format in the VBA constants." & vbCrLf & _
                "Using placeholder dates in filename instead.", vbExclamation, "Filename Date Warning"
         Err.Clear
         formattedDateLow = "DateFrom" ' Use placeholders if parsing failed
         formattedDateHigh = "DateTo"
     End If
     On Error GoTo RestoreFilterAndErrorHandler ' Restore main handler
     formattedTimestamp = Format$(Now, "yyyymmdd_hhmmss") ' Add timestamp for uniqueness
     dynamicFilename = cFILENAME_PREFIX & "_" & formattedDateLow & "-" & formattedDateHigh & "_" & formattedTimestamp & cFILENAME_EXTENSION
     Debug.Print Format(Now, "yyyy-mm-dd hh:nn:ss") & " - Dynamic filename created: " & dynamicFilename


    ' --- Step 2: Navigate to Transaction MB51 ---
    ' Ensures we are in the correct transaction, using /n for robustness.
     ' Check if any unexpected popup window is active first
     If objSess.ActiveWindow.Name <> "wnd[0]" Then
         Debug.Print Format(Now, "yyyy-mm-dd hh:nn:ss") & " - Closing unexpected active window: " & objSess.ActiveWindow.Name & " before navigating."
         objSess.ActiveWindow.Close ' Close unexpected windows (like info popups)
         Sleep 250 ' Short pause after closing window
     End If
     ' Check if already in MB51
     If objSess.Info.TRANSACTION <> UCase(cTRANSACTION) Then
         Debug.Print Format(Now, "yyyy-mm-dd hh:nn:ss") & " - Navigating to transaction /n" & cTRANSACTION & "..."
         objSess.FindById("wnd[0]/tbar[0]/okcd").Text = "/n" & cTRANSACTION ' Use /n to start fresh transaction
         objSess.FindById("wnd[0]").sendVKey 0 ' Press Enter
         Sleep 500 ' Wait slightly longer after /n navigation
     Else
         Debug.Print Format(Now, "yyyy-mm-dd hh:nn:ss") & " - Already in transaction " & cTRANSACTION & "."
     End If


    ' --- Step 3 & 4: Clear Fields & Set Report Criteria ---
    ' Enters the plant, dates, layout, and selects "Flat List"
     ' Clear potentially conflicting fields first (optional but good practice)
     On Error Resume Next ' Ignore errors if fields don't exist on initial screen
     objSess.FindById("wnd[0]/usr/ctxtMATNR-LOW").Text = ""  ' Clear Material Low
     objSess.FindById("wnd[0]/usr/ctxtMATNR-HIGH").Text = "" ' Clear Material High
     ' Add other fields to clear if necessary
     On Error GoTo RestoreFilterAndErrorHandler ' Turn robust error handling back on

     ' Set the required criteria
     objSess.FindById("wnd[0]/usr/ctxtWERKS-LOW").Text = cPLANT      ' Plant
     objSess.FindById("wnd[0]/usr/ctxtBUDAT-LOW").Text = cDATE_LOW   ' Posting Date Low
     objSess.FindById("wnd[0]/usr/ctxtBUDAT-HIGH").Text = cDATE_HIGH ' Posting Date High
     objSess.FindById("wnd[0]/usr/radRFLAT_L").Select                ' Select "Flat List" radio button

     ' Set ALV Layout Variant if specified
     If Trim$(cLAYOUT) <> "" Then
       objSess.FindById("wnd[0]/usr/ctxtALV_DEF").Text = cLAYOUT ' Set ALV Layout field
       Debug.Print Format(Now, "yyyy-mm-dd hh:nn:ss") & " - Setting ALV Layout: " & cLAYOUT
     Else
       objSess.FindById("wnd[0]/usr/ctxtALV_DEF").Text = "" ' Ensure layout field is clear if not used
       Debug.Print Format(Now, "yyyy-mm-dd hh:nn:ss") & " - No ALV Layout specified."
     End If
     Debug.Print Format(Now, "yyyy-mm-dd hh:nn:ss") & " - Transaction " & cTRANSACTION & " criteria set (Plant: " & cPLANT & ", Dates: " & cDATE_LOW & "-" & cDATE_HIGH & ")."


    ' --- Start OLE Message Filter Suppression ---
    ' This attempts to prevent Excel's "Server Busy" or "RPC server unavailable" popups
    ' which can occur during long SAP operations when called from Excel VBA.
     lMsgFilter = 0& ' Use a dummy filter (0 means reject all messages)
     ' Register the dummy filter, storing the pointer to Excel's original filter
     hResult = CoRegisterMessageFilter(lMsgFilter, lPreviousFilter)
     If hResult <> 0 Then
         ' Registration failed (rare, but possible)
         Debug.Print Format(Now, "yyyy-mm-dd hh:nn:ss") & " - Warning: CoRegisterMessageFilter failed to register. HRESULT: " & Hex$(hResult) & ". Proceeding without OLE popup suppression."
         lPreviousFilter = 0 ' Ensure previous filter pointer is invalid if registration failed
     Else
         ' Registration successful
         Debug.Print Format(Now, "yyyy-mm-dd hh:nn:ss") & " - OLE Message Filter registered (suppressing Excel popups during SAP execution)."
     End If


    ' --- Step 5: Execute Report ---
    ' Press the Execute button (usually F8 or a specific button ID)
     objSess.FindById("wnd[0]/tbar[1]/btn[8]").press ' Press Execute (F8) button ID
     Debug.Print Format(Now, "yyyy-mm-dd hh:nn:ss") & " - Execute button (wnd[0]/tbar[1]/btn[8]) pressed."


    ' --- Step 6: Wait for Report Execution (Primary Wait - checks Busy Flag & Status Bar) ---
    ' Waits until SAP is no longer busy OR a completion message appears in the status bar.
     Debug.Print Format(Now, "yyyy-mm-dd hh:nn:ss") & " - Waiting for report execution (Primary Wait - Busy/Status Bar, Timeout: " & cREPORT_EXEC_TIMEOUT_SECONDS & "s)..."
     startTime = Timer ' Record start time for timeout
     Do
         ' Check Status Bar FIRST (sometimes completion message appears while Busy is still true briefly)
         If Not objSBar Is Nothing Then
             currentStatus = Trim$(objSBar.Text) ' Read current status bar text
             ' Check if the status bar contains any of the completion messages
             If (Len(cSTATUS_MSG_COMPLETE_1) > 0 And InStr(1, currentStatus, cSTATUS_MSG_COMPLETE_1, vbTextCompare) > 0) Or _
                (Len(cSTATUS_MSG_COMPLETE_2) > 0 And InStr(1, currentStatus, cSTATUS_MSG_COMPLETE_2, vbTextCompare) > 0) Or _
                (Len(cSTATUS_MSG_COMPLETE_3) > 0 And InStr(1, currentStatus, cSTATUS_MSG_COMPLETE_3, vbTextCompare) > 0) Then
                 Debug.Print Format(Now, "yyyy-mm-dd hh:nn:ss") & " - Completion status detected in status bar: '" & currentStatus & "'"
                 Exit Do ' Exit the wait loop, execution seems complete
             End If
         End If

         ' Check SAP Busy status
         If Not objSess.Busy Then
              ' SAP is no longer busy. Re-check status bar one last time.
              If Not objSBar Is Nothing Then
                  currentStatus = Trim$(objSBar.Text) ' Re-check status bar text
                  If (Len(cSTATUS_MSG_COMPLETE_1) > 0 And InStr(1, currentStatus, cSTATUS_MSG_COMPLETE_1, vbTextCompare) > 0) Or _
                     (Len(cSTATUS_MSG_COMPLETE_2) > 0 And InStr(1, currentStatus, cSTATUS_MSG_COMPLETE_2, vbTextCompare) > 0) Or _
                     (Len(cSTATUS_MSG_COMPLETE_3) > 0 And InStr(1, currentStatus, cSTATUS_MSG_COMPLETE_3, vbTextCompare) > 0) Then
                       Debug.Print Format(Now, "yyyy-mm-dd hh:nn:ss") & " - Completion status detected after Busy=False: '" & currentStatus & "'"
                       Exit Do ' Exit loop, completion confirmed
                  Else
                      ' Busy is false, but expected completion message wasn't seen.
                      ' This might be okay if the grid appears without the message, or it could indicate an issue.
                      Debug.Print Format(Now, "yyyy-mm-dd hh:nn:ss") & " - Busy=False, but final completion status message not detected. Proceeding to check for grid."
                      Exit Do ' Exit primary wait loop and rely on grid check next
                  End If
              Else
                   ' Busy is false, but we couldn't check the status bar. Assume primary wait is over.
                   Debug.Print Format(Now, "yyyy-mm-dd hh:nn:ss") & " - Busy=False, but status bar object not available to check. Exiting primary wait loop."
                   Exit Do ' Exit loop
              End If
         End If

         ' Handle potential popups during the wait
         Call HandleSAPPopups(objSess)

         ' Allow Excel and SAP to process events
         DoEvents
         Sleep 250 ' Short pause (0.25 seconds) to avoid excessive CPU usage

         ' Check for timeout
         If Timer - startTime > cREPORT_EXEC_TIMEOUT_SECONDS Then
             Err.Raise vbObjectError + 513, "RunGUIScript", "Timeout (" & cREPORT_EXEC_TIMEOUT_SECONDS & "s) waiting for primary report execution (Busy flag / Status Bar check)."
         End If
     Loop
     Debug.Print Format(Now, "yyyy-mm-dd hh:nn:ss") & " - Primary wait loop exited."
     Sleep 250 ' Short pause before checking for the grid


    ' --- Step 7: Wait for Grid Control (Secondary Wait - checks for Grid Object) ---
    ' After the primary wait, specifically wait for the ALV grid control to appear.
     Debug.Print Format(Now, "yyyy-mm-dd hh:nn:ss") & " - Waiting for Results Grid Control (" & cGRID_ID & ") (Timeout: " & cGRID_WAIT_TIMEOUT_SECONDS & "s)..."
     startTime = Timer ' Reset start time for this wait phase
     Set gridObject = Nothing ' Ensure grid object is Nothing initially
     Do
         ' Try to find the grid object
         On Error Resume Next ' Ignore error if grid not found yet
         Set gridObject = objSess.FindById(cGRID_ID)
         Dim gridFindErr As Long: gridFindErr = Err.Number
         Err.Clear
         On Error GoTo RestoreFilterAndErrorHandler ' Restore main handler

         If gridFindErr = 0 And Not gridObject Is Nothing Then
             ' Grid object found!
             Debug.Print Format(Now, "yyyy-mm-dd hh:nn:ss") & " - Results Grid object found."
             Exit Do ' Exit the wait loop
         End If

         ' Handle potential popups during this wait too
         Call HandleSAPPopups(objSess)

         ' Check if the active window changed unexpectedly (e.g., error message)
         If objSess.ActiveWindow.Name <> "wnd[0]" Then
              Err.Raise vbObjectError + 514, "RunGUIScript", "SAP Active Window changed unexpectedly to '" & objSess.ActiveWindow.Name & "' while waiting for the results grid. Check SAP screen for errors."
         End If

         ' Allow processing and pause
         DoEvents
         Sleep 250 ' Short pause

         ' Check for timeout
         If Timer - startTime > cGRID_WAIT_TIMEOUT_SECONDS Then
              Err.Raise vbObjectError + 515, "RunGUIScript", "Timeout (" & cGRID_WAIT_TIMEOUT_SECONDS & "s) waiting for results grid control (" & cGRID_ID & ") to appear after execution."
         End If
     Loop
     Debug.Print Format(Now, "yyyy-mm-dd hh:nn:ss") & " - Grid wait loop exited."
     Sleep 100 ' Very short pause before interacting with the grid


    ' --- Step 8: Export Results to Excel ---
    ' Assumes the gridObject was successfully found in the previous step.
     Debug.Print Format(Now, "yyyy-mm-dd hh:nn:ss") & " - Proceeding with export to Excel..."
     success = False ' Reset success flag for export sequence

     ' Double-check grid object validity (optional, but safe)
     If gridObject Is Nothing Then
          On Error Resume Next ' Try one last time to get the grid object
          Set gridObject = objSess.FindById(cGRID_ID)
          On Error GoTo RestoreFilterAndErrorHandler
          If gridObject Is Nothing Then
               Err.Raise vbObjectError + 516, "RunGUIScript", "Export failed: Grid object could not be obtained before export step (" & cGRID_ID & ")."
          End If
          Debug.Print Format(Now, "yyyy-mm-dd hh:nn:ss") & " - Grid object obtained on second attempt just before export."
     End If

     ' --- Export Sequence ---
     ' Use On Error Resume Next for the sequence and check success flag at the end
     On Error Resume Next

     ' 1. Open context menu on the grid
     gridObject.ContextMenu
     If Err.Number <> 0 Then Debug.Print Format(Now, "yyyy-mm-dd hh:nn:ss") & " - Error during ContextMenu: " & Err.Description: Err.Clear: GoTo ExportSequenceErrorCheck

     ' 2. Select "Spreadsheet" (&XXL is the typical internal ID)
     gridObject.SelectContextMenuItem "&XXL"
     If Err.Number <> 0 Then Debug.Print Format(Now, "yyyy-mm-dd hh:nn:ss") & " - Error during SelectContextMenuItem '&XXL': " & Err.Description: Err.Clear: GoTo ExportSequenceErrorCheck

     ' 3. Handle the format confirmation popup (wnd[1]) - Press Continue/Enter (usually btn[0])
     Sleep 250 ' Wait for popup
     objSess.FindById("wnd[1]/tbar[0]/btn[0]").press
     If Err.Number <> 0 Then Debug.Print Format(Now, "yyyy-mm-dd hh:nn:ss") & " - Error pressing Continue on format dialog (wnd[1]/tbar[0]/btn[0]): " & Err.Description: Err.Clear: GoTo ExportSequenceErrorCheck

     ' 4. Handle the file save dialog popup (wnd[1] again, usually)
     Sleep 250 ' Wait for next popup
     ' Set the download directory path
     objSess.FindById("wnd[1]/usr/ctxtDY_PATH").Text = cDOWNLOAD_PATH
     If Err.Number <> 0 Then Debug.Print Format(Now, "yyyy-mm-dd hh:nn:ss") & " - Error setting download path (wnd[1]/usr/ctxtDY_PATH): " & Err.Description: Err.Clear: GoTo ExportSequenceErrorCheck

     ' Set the dynamic filename
     objSess.FindById("wnd[1]/usr/ctxtDY_FILENAME").Text = dynamicFilename
     If Err.Number <> 0 Then Debug.Print Format(Now, "yyyy-mm-dd hh:nn:ss") & " - Error setting download filename (wnd[1]/usr/ctxtDY_FILENAME): " & Err.Description: Err.Clear: GoTo ExportSequenceErrorCheck

     ' 5. Press the "Replace" or "Generate" or "Save" button (often btn[11] for Replace/Generate)
     '    <<< CHECK THIS BUTTON ID if export fails - use Script Recorder if needed >>>
     objSess.FindById("wnd[1]/tbar[0]/btn[11]").press
     If Err.Number <> 0 Then Debug.Print Format(Now, "yyyy-mm-dd hh:nn:ss") & " - Error pressing Save/Generate/Replace button (wnd[1]/tbar[0]/btn[11]): " & Err.Description: Err.Clear: GoTo ExportSequenceErrorCheck

     ' If we reached here without errors in the sequence, assume success
     success = (Err.Number = 0)
     If success Then Debug.Print Format(Now, "yyyy-mm-dd hh:nn:ss") & " - Export commands sent successfully to: " & cDOWNLOAD_PATH & "\" & dynamicFilename
     Sleep 1000 ' Wait 1 second for file writing to begin

ExportSequenceErrorCheck:
     On Error GoTo RestoreFilterAndErrorHandler ' Restore main handler
     ' Check if the success flag was set
     If Not success Then
          ' Raise an error if any step in the sequence failed
          Err.Raise vbObjectError + 517, "RunGUIScript", "Export sequence failed. Check Debug.Print messages above for specific step." & vbCrLf & _
                    "Ensure path '" & cDOWNLOAD_PATH & "' exists and is writable." & vbCrLf & _
                    "Verify SAP GUI permissions allow export and check button IDs (especially wnd[1]/btn[11])."
     End If

    ' If export was successful, proceed to normal exit
    GoTo RestoreFilterAndExit


' //------------------------------------------------------------------------
' // Error Handler and Cleanup Section for RunGUIScript
' //------------------------------------------------------------------------
RestoreFilterAndErrorHandler:
    ' This block is executed if any runtime error occurs within RunGUIScript
     Dim errNum As Long: errNum = Err.Number
     Dim errDesc As String: errDesc = Err.Description
     Dim errSource As String: errSource = Err.Source

     ' Log the error details to the Immediate Window (Ctrl+G in VBA Editor)
     Debug.Print "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
     Debug.Print Format(Now, "yyyy-mm-dd hh:nn:ss") & " - ERROR ENCOUNTERED in RunGUIScript!"
     Debug.Print "    Error #: " & errNum
     Debug.Print "    Source:  " & errSource
     Debug.Print "    Desc:    " & errDesc
     Debug.Print "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"

     ' --- Attempt to Restore OLE Message Filter ---
     ' Important to restore Excel's normal behavior even if an error occurred.
     If lPreviousFilter <> 0 Then ' Check if filter was successfully registered earlier
         On Error Resume Next ' Don't let filter restoration cause another error
         hResult = CoRegisterMessageFilter(lPreviousFilter, lMsgFilter) ' Restore original filter
         If hResult <> 0 Then
              Debug.Print Format(Now, "yyyy-mm-dd hh:nn:ss") & " - Warning: CoRegisterMessageFilter failed to RESTORE during error handling. HRESULT: " & Hex$(hResult)
         Else
              Debug.Print Format(Now, "yyyy-mm-dd hh:nn:ss") & " - OLE Message Filter restored during error handling."
         End If
         lPreviousFilter = 0 ' Reset pointer
         On Error GoTo 0 ' Turn off Resume Next immediately after
     End If

     ' --- Show Error Message to User ---
     MsgBox "A critical error occurred during SAP GUI script execution (MB51):" & vbCrLf & vbCrLf & _
            "Error Number: " & errNum & vbCrLf & _
            "Source: " & errSource & vbCrLf & _
            "Description: " & errDesc & vbCrLf & vbCrLf & _
            "The script will attempt to exit gracefully. Please check the SAP screen state and Debug messages (Ctrl+G in VBA editor).", _
            vbCritical, "SAP Scripting Runtime Error"

     ' --- Attempt Basic SAP Cleanup After Error ---
     ' Try to close popups or navigate back to avoid leaving SAP in a strange state.
     On Error Resume Next ' Use Resume Next for cleanup attempts
     If Not objSess Is Nothing Then
         Debug.Print Format(Now, "yyyy-mm-dd hh:nn:ss") & " - Attempting SAP cleanup after error..."
         If objSess.Busy Then Sleep 500 ' Wait if busy
         ' Try closing popups (Cancel/Close button is often btn[12])
         If objSess.ActiveWindow.Name = "wnd[1]" Or objSess.ActiveWindow.Name = "wnd[2]" Then
              objSess.FindById("wnd[0]/tbar[0]/btn[12]").press
              Sleep 250
         End If
         ' Try exiting the transaction (Exit button is often btn[15])
         If objSess.ActiveWindow.Name = "wnd[0]" Then
              objSess.FindById("wnd[0]/tbar[0]/btn[15]").press
              Sleep 250
         End If
         Debug.Print Format(Now, "yyyy-mm-dd hh:nn:ss") & " - SAP cleanup attempt finished (errors during cleanup ignored)."
     End If
     ' Do not resume - proceed directly to final cleanup
     GoTo FinalCleanup


' //------------------------------------------------------------------------
' // Normal Exit and Final Cleanup Section for RunGUIScript
' //------------------------------------------------------------------------
RestoreFilterAndExit:
    ' This block is executed after successful export.

    ' --- Restore OLE Message Filter ---
    If lPreviousFilter <> 0 Then ' Check if filter was registered
        On Error Resume Next ' Don't let filter restoration cause an error
        hResult = CoRegisterMessageFilter(lPreviousFilter, lMsgFilter) ' Restore original filter
        If hResult <> 0 Then
             Debug.Print Format(Now, "yyyy-mm-dd hh:nn:ss") & " - Warning: CoRegisterMessageFilter failed to RESTORE during normal exit. HRESULT: " & Hex$(hResult)
        Else
             Debug.Print Format(Now, "yyyy-mm-dd hh:nn:ss") & " - OLE Message Filter restored during normal exit."
        End If
        lPreviousFilter = 0 ' Reset pointer
        On Error GoTo 0 ' Turn off Resume Next
    End If

    ' --- Navigate Back in SAP (Optional Cleanup) ---
    ' Try to navigate back from the results screen or transaction.
    On Error Resume Next ' Attempt cleanup gracefully
    Debug.Print Format(Now, "yyyy-mm-dd hh:nn:ss") & " - Navigating back in SAP after successful run..."
    If Not objSess Is Nothing Then
        If objSess.ActiveWindow.Name = "wnd[0]" Then
            ' If in main window, try Exit (btn[15]) first
            objSess.FindById("wnd[0]/tbar[0]/btn[15]").press ' Exit btn[15]
            Sleep 100
            ' If still in MB51 after Exit (e.g., if Exit just closed results), try Back (btn[3])
            If objSess.Info.TRANSACTION = UCase(cTRANSACTION) Then
                 objSess.FindById("wnd[0]/tbar[0]/btn[3]").press ' Back btn[3]
            End If
        ElseIf objSess.ActiveWindow.Name = "wnd[1]" Or objSess.ActiveWindow.Name = "wnd[2]" Then
             ' If a popup is somehow still active, try Cancel/Close (btn[12])
             objSess.FindById("wnd[0]/tbar[0]/btn[12]").press
        End If
    End If
    Debug.Print Format(Now, "yyyy-mm-dd hh:nn:ss") & " - SAP navigation cleanup finished (errors ignored)."
    On Error GoTo 0 ' Restore default error handling

    Debug.Print Format(Now, "yyyy-mm-dd hh:nn:ss") & " - RunGUIScript finished normally."
    ' Fall through to FinalCleanup

FinalCleanup:
    ' Restore Excel settings (might be redundant if main sub also does it, but safe)
    Application.Calculation = xlCalculationAutomatic
    Application.ScreenUpdating = True
    On Error GoTo 0 ' Ensure error handling is off
    Debug.Print Format(Now, "yyyy-mm-dd hh:nn:ss") & " - Exiting RunGUIScript."
    ' Return control to StartMB51Extract
End Sub


' //========================================================================
' // Sub: HandleSAPPopups (Helper Function)
' // Purpose: Checks for and handles common SAP modal dialogs (Information,
' //          Confirmation, etc.) that might appear unexpectedly during
' //          long-running operations or waits. Typically tries sending Enter.
' // Arguments: currentSession - The active SAP GUI Session object to check.
' //========================================================================
Private Sub HandleSAPPopups(ByVal currentSession As GuiSession)
    ' Handles common modal windows (wnd[1], wnd[2]) by trying to send Enter or press default button.
     Dim popupWindow As GuiModalWindow ' Object to represent the popup
     Dim popupID As String             ' ID of the popup window ("wnd[1]" or "wnd[2]")
     Dim handledPopup As Boolean: handledPopup = False ' Flag

     On Error Resume Next ' Enable error resumption specifically for finding popups

     ' Check for the most common popup window IDs
     For Each popupID In Array("wnd[1]", "wnd[2]")
         Set popupWindow = Nothing ' Reset before check
         ' Try to find the popup window without causing an error if it doesn't exist
         Set popupWindow = currentSession.FindById(popupID, False) ' False = Don't error if not found

         If Err.Number = 0 And Not popupWindow Is Nothing Then
             ' Found a popup window!
             handledPopup = True
             Debug.Print Format(Now, "yyyy-mm-dd hh:nn:ss") & " - Detected SAP popup window: " & popupID & " (Type: " & popupWindow.Type & ", Text: '" & popupWindow.Text & "')"

             ' Attempt to handle it (usually by sending Enter)
             Debug.Print "    -> Attempting to send VKey 0 (Enter)..."
             popupWindow.sendVKey 0 ' Try sending Enter (Virtual Key 0)
             If Err.Number <> 0 Then
                 ' Sending Enter failed, try pressing the default button (usually btn[0])
                 Debug.Print "    -> Failed to send VKey 0 to " & popupID & ". Error: " & Err.Description
                 Err.Clear ' Clear the VKey error
                 Debug.Print "    -> Attempting to press btn[0]..."
                 On Error Resume Next ' Try pressing default button
                 popupWindow.FindById("tbar[0]/btn[0]").press
                 If Err.Number <> 0 Then
                      Debug.Print "    -> Failed to press btn[0] on " & popupID & ". Error: " & Err.Description
                      Err.Clear ' Clear the button press error
                 Else
                      Debug.Print "    -> Pressed btn[0] on " & popupID & "."
                 End If
                 On Error GoTo 0 ' Restore default handler after trying button
             Else
                 ' Sending Enter succeeded
                 Debug.Print "    -> Sent VKey 0 (Enter) to " & popupID & " successfully."
             End If
             Sleep 500 ' Wait a bit after handling the popup
             Exit For ' Assume only one popup needs handling per check cycle
         End If
         ' Clear any error from FindById if the popup wasn't found
         If Err.Number <> 0 Then Err.Clear
     Next popupID

     On Error GoTo 0 ' Disable error resumption for the rest of the calling code

End Sub
