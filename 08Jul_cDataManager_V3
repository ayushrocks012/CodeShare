'@Folder("Classes")
Option Explicit

'================================================================================================
' Class:       cDataManager
' Purpose:     Encapsulates all data loading, validation, and caching logic. This class
'              acts as the single source of truth for all data required by the forecasting
'              engine, abstracting away the details of reading from Excel sheets.
' Version:     1.0
' Author:      Ayush Goyal
' Date:        08-Jul-2025
'================================================================================================

' --- Private Member Variables ---
Private m_wbHost As Workbook
Private m_wsLog As Worksheet
Private m_lngWarningCount As Long

' --- Raw Data Arrays ---
Private m_arrStatusData As Variant
Private m_arrHistoryData As Variant
Private m_arrDemandData As Variant

' --- Processed Data Collections & Caches ---
Private m_dictForecastItemMap As Object
Private m_dictAffiliates As Object
Private m_dictKeyFigures As Object
Private m_dictHistoryCache As Object
Private m_dictHistSumCache As Object
Private m_dictDemandCache As Object
Private m_dictValidatedChains As Object

' --- Public Read-Only Properties to Access Data ---
Public Property Get ForecastItems() As Object: Set ForecastItems = m_dictForecastItemMap: End Property
Public Property Get Affiliates() As Object: Set Affiliates = m_dictAffiliates: End Property
Public Property Get KeyFigures() As Object: Set KeyFigures = m_dictKeyFigures: End Property
Public Property Get HistorySumCache() As Object: Set HistorySumCache = m_dictHistSumCache: End Property
Public Property Get DemandCache() As Object: Set DemandCache = m_dictDemandCache: End Property
Public Property Get DemandDataArray() As Variant: DemandDataArray = m_arrDemandData: End Property
Public Property Get HistoryDataArray() As Variant: HistoryDataArray = m_arrHistoryData: End Property
Public Property Get HistoryCache() As Object: Set HistoryCache = m_dictHistoryCache: End Property
Public Property Get WarningCount() As Long: WarningCount = m_lngWarningCount: End Property

'================================================================================================
'--- INITIALIZATION & PUBLIC METHODS ---
'================================================================================================

'---------------------------------------------------------------------------------
' Procedure : Init
' Purpose   : Initializes the data manager with required external objects.
'---------------------------------------------------------------------------------
Public Sub Init(ByVal hostWorkbook As Workbook, ByVal logSheet As Worksheet)
    Set m_wbHost = hostWorkbook
    Set m_wsLog = logSheet
    m_lngWarningCount = 0
End Sub

'---------------------------------------------------------------------------------
' Procedure : LoadAndProcessData
' Purpose   : Main public method to orchestrate all data loading and processing steps.
' @return  : Boolean - True if successful, False otherwise.
'---------------------------------------------------------------------------------
Public Function LoadAndProcessData() As Boolean
    Dim tCheckpoint As Double: tCheckpoint = Timer
    
    If Not LoadAndValidateSourceSheets() Then GoTo Main_Exit
    
    Application.StatusBar = "Building data caches and maps..."
    
    Set m_dictForecastItemMap = BuildForecastItemMap(m_arrStatusData)
    ValidateSuccessorLinks
    
    Set m_dictAffiliates = GetUniqueValues(m_arrDemandData, g_dsDemand.GetCol("Affiliate"))
    Set m_dictKeyFigures = GetUniqueValues(m_arrDemandData, g_dsDemand.GetCol("KeyFigure"))
    
    BuildHistoryCache
    BuildDataCaches
    
    LogPerformance tCheckpoint, "Build Caches and Maps"
    LoadAndProcessData = True
    Exit Function
    
Main_Exit:
    LoadAndProcessData = False
End Function

'================================================================================================
'--- PRIVATE DATA LOADING AND VALIDATION ---
'================================================================================================

'---------------------------------------------------------------------------------
' Procedure : LoadAndValidateSourceSheets
' Purpose   : Validates and loads all required source data into memory.
' @return  : Boolean - True if all sheets are found and loaded, False otherwise.
'---------------------------------------------------------------------------------
Private Function LoadAndValidateSourceSheets() As Boolean
    Dim tCheckpoint As Double: tCheckpoint = Timer
    On Error GoTo Load_ErrorHandler
    
    Application.StatusBar = "Loading and validating source data..."
    
    If Not SheetExists(g_dsProductStatus.SheetName) Then Err.Raise 515, , "Required sheet '" & g_dsProductStatus.SheetName & "' not found."
    If Not SheetExists(g_dsHistory.SheetName) Then Err.Raise 516, , "Required sheet '" & g_dsHistory.SheetName & "' not found."
    If Not SheetExists(g_dsDemand.SheetName) Then Err.Raise 517, , "Required sheet '" & g_dsDemand.SheetName & "' not found."
    
    m_arrStatusData = LoadDataToArray(m_wbHost.Sheets(g_dsProductStatus.SheetName))
    m_arrHistoryData = LoadDataToArray(m_wbHost.Sheets(g_dsHistory.SheetName))
    m_arrDemandData = LoadDataToArray(m_wbHost.Sheets(g_dsDemand.SheetName))
    
    WriteToLog ltInfo, "DataManager.Load", "All source data loaded and validated."
    LogPerformance tCheckpoint, "Load & Validate Data"
    LoadAndValidateSourceSheets = True
    Exit Function

Load_ErrorHandler:
    Dim strErrorMsg As String: strErrorMsg = "Failed to load source sheets. " & vbCrLf & Err.Description
    WriteToLog ltFatal, "DataManager.Load", strErrorMsg, Err.Number
    MsgBox strErrorMsg, vbCritical, "Process Halted"
    LoadAndValidateSourceSheets = False
End Function

'---------------------------------------------------------------------------------
' Procedure : BuildForecastItemMap
' Purpose   : Creates the master dictionary of all forecast item objects.
'---------------------------------------------------------------------------------
Private Function BuildForecastItemMap(ByVal arrStatus As Variant) As Object
    Dim dictMap As Object: Set dictMap = CreateObject("Scripting.Dictionary")
    Dim rowIndex As Long
    Dim obj As cForecastItem
    Dim key As cDimensionKey
    
    For rowIndex = 2 To UBound(arrStatus, 1)
        Set key = New cDimensionKey
        key.Add "Affiliate", arrStatus(rowIndex, g_dsProductStatus.GetCol("Affiliate"))
        key.Add "ISD", arrStatus(rowIndex, g_dsProductStatus.GetCol("ISD"))
        Dim strKey As String: strKey = key.ToString()
        
        If Not dictMap.Exists(strKey) Then
            Set obj = New cForecastItem
            obj.Init g_dsProductStatus, arrStatus, rowIndex
            dictMap.Add strKey, obj
        Else
            m_lngWarningCount = m_lngWarningCount + 1
            WriteToLog ltWarning, "DataManager.BuildMap", "Duplicate item found. Ignoring duplicate on row " & rowIndex & ".", , "Original: " & dictMap.Item(strKey).DebugSummary()
        End If
    Next rowIndex
    Set BuildForecastItemMap = dictMap
End Function

'---------------------------------------------------------------------------------
' Procedure : ValidateSuccessorLinks
' Purpose   : Iterates through all item objects to validate successor links.
'---------------------------------------------------------------------------------
Private Sub ValidateSuccessorLinks()
    Dim tCheckpoint As Double: tCheckpoint = Timer
    Dim itemKey As Variant, currentItem As cForecastItem
    
    WriteToLog ltInfo, "DataManager.Validation", "Starting validation of successor item links..."
    Set m_dictValidatedChains = CreateObject("Scripting.Dictionary")
    
    For Each itemKey In m_dictForecastItemMap.Keys
        Set currentItem = m_dictForecastItemMap.Item(itemKey)
        If Not m_dictValidatedChains.Exists(itemKey) Then ValidateSingleChain currentItem
    Next itemKey
    
    LogPerformance tCheckpoint, "Validate Successor Links"
End Sub

'---------------------------------------------------------------------------------
' Procedure : ValidateSingleChain
' Purpose   : Recursively checks a single chain of item successions for loops.
'---------------------------------------------------------------------------------
Private Sub ValidateSingleChain(ByVal startItem As cForecastItem)
    Dim pathTracker As Object: Set pathTracker = CreateObject("Scripting.Dictionary")
    Dim currentItem As cForecastItem: Set currentItem = startItem
    Dim successorKey As cDimensionKey
    Dim strSuccessorKey As String, chainIsValid As Boolean: chainIsValid = True
    
    Do While True
        If pathTracker.Exists(currentItem.ISD) Then
            m_lngWarningCount = m_lngWarningCount + 1
            WriteToLog ltWarning, "DataManager.Validation", "Circular reference detected.", , "Item '" & startItem.DebugSummary() & "' is part of a successor loop."
            chainIsValid = False: Exit Do
        End If
        pathTracker.Add currentItem.ISD, 1
        
        If Len(currentItem.SupersededByProductID) = 0 Then Exit Do
        
        Dim currentItemKey As String: currentItemKey = currentItem.Dimensions.ToString()
        If m_dictValidatedChains.Exists(currentItemKey) Then
            If Not m_dictValidatedChains.Item(currentItemKey) Then chainIsValid = False
            Exit Do
        End If
        
        Set successorKey = New cDimensionKey
        successorKey.Add "Affiliate", currentItem.Affiliate
        successorKey.Add "ISD", currentItem.SupersededByProductID
        strSuccessorKey = successorKey.ToString()
        
        If Not m_dictForecastItemMap.Exists(strSuccessorKey) Then
            m_lngWarningCount = m_lngWarningCount + 1
            WriteToLog ltWarning, "DataManager.Validation", "Successor item not found (broken link).", , "Item '" & currentItem.DebugSummary() & "' lists non-existent successor ISD '" & currentItem.SupersededByProductID & "'."
            chainIsValid = False: Exit Do
        End If
        
        Set currentItem = m_dictForecastItemMap.Item(strSuccessorKey)
    Loop
    
    Dim pathKey As Variant
    Dim itemMapKey As cDimensionKey
    For Each pathKey In pathTracker.Keys
        Set itemMapKey = New cDimensionKey
        itemMapKey.Add "Affiliate", startItem.Affiliate
        itemMapKey.Add "ISD", pathKey
        
        Dim strItemMapKey As String: strItemMapKey = itemMapKey.ToString()
        If Not m_dictValidatedChains.Exists(strItemMapKey) Then
            m_dictValidatedChains.Add strItemMapKey, chainIsValid
        End If
    Next pathKey
End Sub

'================================================================================================
'--- PRIVATE CACHING LOGIC ---
'================================================================================================

'---------------------------------------------------------------------------------
' Procedure : BuildHistoryCache
' Purpose   : Builds a cache for monthly historical data for reporting.
'---------------------------------------------------------------------------------
Private Sub BuildHistoryCache()
    Set m_dictHistoryCache = CreateObject("Scripting.Dictionary")
    Dim r As Long, c As Long
    Dim strKey As String
    Dim dictMonthlyValues As Object
    Dim key As cDimensionKey
    
    For r = 2 To UBound(m_arrHistoryData, 1)
        Set key = New cDimensionKey
        key.Add "Affiliate", m_arrHistoryData(r, g_dsHistory.GetCol("Affiliate"))
        key.Add "KeyFigure", m_arrHistoryData(r, g_dsHistory.GetCol("KeyFigure"))
        key.Add "LocalItemNbr", m_arrHistoryData(r, g_dsHistory.GetCol("LocalItemNbr"))
        strKey = key.ToString()
        
        If Not m_dictHistoryCache.Exists(strKey) Then
            Set dictMonthlyValues = CreateObject("Scripting.Dictionary")
            For c = g_dsHistory.StartOfMonthsCol To UBound(m_arrHistoryData, 2)
                dictMonthlyValues.Add CDate(m_arrHistoryData(1, c)), m_arrHistoryData(r, c)
            Next c
            m_dictHistoryCache.Add strKey, dictMonthlyValues
        End If
    Next r
End Sub

'---------------------------------------------------------------------------------
' Procedure : BuildDataCaches
' Purpose   : Builds high-performance caches for historical sums and demand values.
'---------------------------------------------------------------------------------
Private Sub BuildDataCaches()
    Dim r As Long, c As Long
    Dim dblSum As Double
    Dim subTierKey As cDimensionKey, tierKey As cDimensionKey, demandKey As cDimensionKey
    
    ' --- Build Historical Sum Cache ---
    Set m_dictHistSumCache = CreateObject("Scripting.Dictionary")
    m_dictHistSumCache.CompareMode = vbTextCompare
    For r = 2 To UBound(m_arrHistoryData, 1)
        Set subTierKey = New cDimensionKey
        subTierKey.Add CALC_AFFILIATE_DIM, m_arrHistoryData(r, g_dsHistory.GetCol("Affiliate"))
        subTierKey.Add CALC_TOTAL_LEVEL_DIM, m_arrHistoryData(r, g_dsHistory.GetCol("Tier"))
        subTierKey.Add CALC_SHARE_LEVEL_DIM, m_arrHistoryData(r, g_dsHistory.GetCol("SubTier"))
        subTierKey.Add CALC_KEY_FIGURE_DIM, m_arrHistoryData(r, g_dsHistory.GetCol("KeyFigure"))
        
        Set tierKey = New cDimensionKey
        tierKey.Add CALC_AFFILIATE_DIM, m_arrHistoryData(r, g_dsHistory.GetCol("Affiliate"))
        tierKey.Add CALC_TOTAL_LEVEL_DIM, m_arrHistoryData(r, g_dsHistory.GetCol("Tier"))
        tierKey.Add CALC_KEY_FIGURE_DIM, m_arrHistoryData(r, g_dsHistory.GetCol("KeyFigure"))
                 
        dblSum = 0
        For c = g_dsHistory.StartOfMonthsCol To UBound(m_arrHistoryData, 2)
            If IsNumeric(m_arrHistoryData(r, c)) Then dblSum = dblSum + CDbl(m_arrHistoryData(r, c))
        Next c
        
        m_dictHistSumCache.Item(subTierKey.ToString()) = m_dictHistSumCache.Item(subTierKey.ToString()) + dblSum
        m_dictHistSumCache.Item(tierKey.ToString()) = m_dictHistSumCache.Item(tierKey.ToString()) + dblSum
    Next r

    ' --- Build Demand Forecast Cache ---
    Set m_dictDemandCache = CreateObject("Scripting.Dictionary")
    m_dictDemandCache.CompareMode = vbTextCompare
    For r = 2 To UBound(m_arrDemandData, 1)
        For c = g_dsDemand.StartOfMonthsCol To UBound(m_arrDemandData, 2)
            Set demandKey = New cDimensionKey
            demandKey.Add CALC_AFFILIATE_DIM, m_arrDemandData(r, g_dsDemand.GetCol("Affiliate"))
            demandKey.Add CALC_TOTAL_LEVEL_DIM, m_arrDemandData(r, g_dsDemand.GetCol("Tier"))
            demandKey.Add CALC_KEY_FIGURE_DIM, m_arrDemandData(r, g_dsDemand.GetCol("KeyFigure"))
            demandKey.Add "Month", CDate(m_arrDemandData(1, c))
            
            If IsNumeric(m_arrDemandData(r, c)) Then
                m_dictDemandCache.Add demandKey.ToString(), CDbl(m_arrDemandData(r, c))
            Else
                m_dictDemandCache.Add demandKey.ToString(), 0
            End If
        Next c
    Next r
End Sub

'================================================================================================
'--- UTILITY & HELPER FUNCTIONS ---
'================================================================================================

'---------------------------------------------------------------------------------
' Procedure : SheetExists
' Purpose   : Safely checks if a worksheet exists.
'---------------------------------------------------------------------------------
Private Function SheetExists(ByVal sheetName As String) As Boolean
    Dim ws As Worksheet
    On Error Resume Next
    Set ws = m_wbHost.Sheets(sheetName)
    On Error GoTo 0
    SheetExists = Not ws Is Nothing
End Function

'---------------------------------------------------------------------------------
' Procedure : LoadDataToArray
' Purpose   : Reads a worksheet's used range into a variant array.
'---------------------------------------------------------------------------------
Private Function LoadDataToArray(ByVal ws As Worksheet) As Variant
    If ws Is Nothing Then Exit Function
    Dim lRow As Long: lRow = ws.Cells(ws.Rows.Count, "A").End(xlUp).Row
    Dim lCol As Long: lCol = ws.Cells(1, ws.Columns.Count).End(xlToLeft).Column
    If lRow > 1 And lCol > 0 Then LoadDataToArray = ws.Range("A1", ws.Cells(lRow, lCol)).Value
End Function

'---------------------------------------------------------------------------------
' Procedure : GetUniqueValues
' Purpose   : Extracts a list of unique values from a specific column of an array.
'---------------------------------------------------------------------------------
Private Function GetUniqueValues(arrData As Variant, ByVal lngCol As Long) As Object
    Dim dict As Object: Set dict = CreateObject("Scripting.Dictionary")
    dict.CompareMode = vbTextCompare
    Dim rowIndex As Long
    For rowIndex = 2 To UBound(arrData, 1)
        If Not IsEmpty(arrData(rowIndex, lngCol)) Then
            If Not dict.Exists(arrData(rowIndex, lngCol)) Then
                dict.Add arrData(rowIndex, lngCol), 1
            End If
        End If
    Next rowIndex
    Set GetUniqueValues = dict
End Function

'---------------------------------------------------------------------------------
' Procedure : WriteToLog
' Purpose   : Writes a new entry to the log sheet.
'---------------------------------------------------------------------------------
Private Sub WriteToLog(ByVal logType As logType, ByVal procedureName As String, ByVal message As String, Optional ByVal errNumber As Long = 0, Optional ByVal errContext As String = "")
    If m_wsLog Is Nothing Then Exit Sub
    Dim nextRow As Long: nextRow = m_wsLog.Cells(m_wsLog.Rows.Count, "A").End(xlUp).Row + 1
    With m_wsLog.Rows(nextRow)
        .Cells(1).Value = Now(): .Cells(2).Value = GetLogTypeString(logType)
        .Cells(3).Value = procedureName: .Cells(4).Value = message
        If errNumber <> 0 Then .Cells(5).Value = "Err " & errNumber & ": " & errContext Else .Cells(5).Value = errContext
    End With
End Sub

'---------------------------------------------------------------------------------
' Procedure : LogPerformance
' Purpose   : A specialized logging function to record the time taken for major stages.
'---------------------------------------------------------------------------------
Private Sub LogPerformance(ByRef tCheckpoint As Double, ByVal strStageName As String)
    WriteToLog ltProfile, strStageName, "Stage completed in " & format$(Timer - tCheckpoint, "#,##0.00") & "s"
    tCheckpoint = Timer
End Sub

'---------------------------------------------------------------------------------
' Procedure : GetLogTypeString
' Purpose   : Converts a logType enum value to its string representation.
'---------------------------------------------------------------------------------
Private Function GetLogTypeString(ByVal logType As logType) As String
    Select Case logType
        Case ltInfo: GetLogTypeString = "Info"
        Case ltWarning: GetLogTypeString = "Warning"
        Case ltError: GetLogTypeString = "Error"
        Case ltFatal: GetLogTypeString = "FATAL"
        Case ltProfile: GetLogTypeString = "Profile"
    End Select
End Function

' --- Destructor ---
Private Sub Class_Terminate()
    Set m_wbHost = Nothing
    Set m_wsLog = Nothing
    Set m_dictForecastItemMap = Nothing
    Set m_dictAffiliates = Nothing
    Set m_dictKeyFigures = Nothing
    Set m_dictHistoryCache = Nothing
    Set m_dictHistSumCache = Nothing
    Set m_dictDemandCache = Nothing
    Set m_dictValidatedChains = Nothing
    
    Erase m_arrStatusData
    Erase m_arrHistoryData
    Erase m_arrDemandData
End Sub
