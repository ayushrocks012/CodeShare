'@Folder("Forecasting")
Option Explicit

'================================================================================================================
' --- FORECASTING ENGINE MODULE (M_Forecasting) ---
' V14: Architectural Refactoring
'      - Refactored the main procedure into a clear, step-by-step workflow (Initialize, Load, Process, Finalize).
'      - Modularized forecast logic: separated "finding sheets" from "processing sheets".
'      - Modularized formatting logic: broke down FormatEnhancedSheet into smaller, single-purpose subs.
'      - Encapsulated successor-linking logic into the cProductLifecycle class.
'
' Author:      [Your Name]
' Date:        [Current Date]
'================================================================================================================

'--- PRIVATE MODULE-LEVEL VARIABLES ---
Private wbHost As Workbook
Private wsLog As Worksheet
Private lngWarningCount As Long
Private dictDemandCache As Object
Private arrStatusData As Variant, arrHistoryData As Variant, arrDemandData As Variant
Private dictLifecycleMap As Object, dictAffiliates As Object

'================================================================================================================
' 1. Main Public Orchestrator
'================================================================================================================

Public Sub UpdateForecast_V7()
    Dim tStart As Double: tStart = Timer
    
    'REFACTOR #1: Main procedure is now a clean, readable workflow.
    If Not InitializeRun() Then GoTo Main_Exit
    If Not LoadAndValidateData() Then GoTo Main_Exit
    
    BuildCachesAndMaps
    ProcessAllAffiliates
    
Main_Exit:
    FinalizeRun tStart
End Sub

'================================================================================================================
' 2. Main Workflow Stages
'================================================================================================================

Private Function InitializeRun() As Boolean
    Dim tCheckpoint As Double: tCheckpoint = Timer
    
    Application.EnableCancelKey = xlErrorHandler
    On Error GoTo Init_ErrorHandler
    
    If ThisWorkbook.ReadOnly Then
        MsgBox "This workbook is in Read-Only mode. Please save a copy or enable editing to run the forecast.", vbCritical, "Process Halted"
        Exit Function
    End If
    
    Application.ScreenUpdating = False
    Application.DisplayAlerts = False
    Application.Calculation = xlCalculationManual
    Application.EnableEvents = False
    Application.StatusBar = "Initializing environment..."
    
    lngWarningCount = 0
    Set wbHost = ThisWorkbook
    
    On Error Resume Next
    wbHost.Sheets(SHEET_LOG).Delete
    On Error GoTo Init_ErrorHandler
    
    Set wsLog = wbHost.Sheets.Add(After:=wbHost.Sheets(wbHost.Sheets.Count))
    InitializeLogSheet wsLog
    
    LogPerformance tCheckpoint, "Initialize Environment"
    InitializeRun = True
    Exit Function

Init_ErrorHandler:
    MsgBox "A critical error occurred during initialization: " & Err.Description, vbCritical, "Initialization Failed"
    InitializeRun = False
End Function

Private Function LoadAndValidateData() As Boolean
    Dim tCheckpoint As Double: tCheckpoint = Timer
    On Error GoTo Load_ErrorHandler
    
    Application.StatusBar = "Loading and validating source data..."
    
    arrStatusData = LoadDataToArray(wbHost.Sheets(SHEET_STATUS))
    arrHistoryData = LoadDataToArray(wbHost.Sheets(SHEET_HISTORY))
    arrDemandData = LoadDataToArray(wbHost.Sheets(SHEET_DEMAND))
    
    If Not IsArray(arrStatusData) Or UBound(arrStatusData, 1) < 2 Then Err.Raise 515, , "Sheet '" & SHEET_STATUS & "' is missing or empty."
    If Not IsArray(arrHistoryData) Or UBound(arrHistoryData, 1) < 2 Then Err.Raise 516, , "Sheet '" & SHEET_HISTORY & "' is missing or empty."
    If Not IsArray(arrDemandData) Or UBound(arrDemandData, 1) < 2 Then Err.Raise 517, , "Sheet '" & SHEET_DEMAND & "' is missing or empty."
    
    WriteToLog "Info", "LoadAndValidateData", "All source data loaded and validated."
    LogPerformance tCheckpoint, "Load & Validate Data"
    LoadAndValidateData = True
    Exit Function

Load_ErrorHandler:
    Dim strErrorMsg As String
    strErrorMsg = "Failed to load source sheets. " & vbCrLf & vbCrLf & Err.Description
    WriteToLog "FATAL", "LoadAndValidateData", strErrorMsg
    MsgBox strErrorMsg, vbCritical, "Process Halted"
    LoadAndValidateData = False
End Function

Private Sub BuildCachesAndMaps()
    Dim tCheckpoint As Double: tCheckpoint = Timer
    
    Set dictLifecycleMap = BuildLifecycleMap(arrStatusData)
    LogPerformance tCheckpoint, "Build Lifecycle Map"
    
    Set dictAffiliates = GetUniqueAffiliates(arrDemandData)
    CacheDemandDataRows arrDemandData
    LogPerformance tCheckpoint, "Cache Demand & Affiliate Data"
End Sub

Private Sub ProcessAllAffiliates()
    Dim varAffiliateKey As Variant, strCurrentAffiliate As String
    Dim lngAffiliateCounter As Long, lngTotalAffiliates As Long
    Dim tCheckpoint As Double: tCheckpoint = Timer
    
    lngTotalAffiliates = dictAffiliates.Count
    If lngTotalAffiliates = 0 Then
        WriteToLog "Warning", "ProcessAllAffiliates", "No affiliates found. Nothing to process."
        Exit Sub
    End If
    
    Dim lngHistMonthCount As Long
    lngHistMonthCount = GetHistoricalMonthCount(arrDemandData, arrHistoryData)
    
    For Each varAffiliateKey In dictAffiliates.Keys
        strCurrentAffiliate = CStr(varAffiliateKey)
        lngAffiliateCounter = lngAffiliateCounter + 1
        On Error GoTo Affiliate_ErrorHandler
        
        If Not DEBUG_MODE Then
            Application.StatusBar = "Processing Affiliate: " & strCurrentAffiliate & " (" & lngAffiliateCounter & " of " & lngTotalAffiliates & ")..."
        End If
        WriteToLog "Info", "ProcessAllAffiliates", "Starting: " & strCurrentAffiliate
        
        ProcessForecastForAffiliate strCurrentAffiliate, lngHistMonthCount
        
        GoTo Next_Affiliate
Affiliate_ErrorHandler:
        lngWarningCount = lngWarningCount + 1
        WriteToLog "Error", "ProcessAllAffiliates", "Failed affiliate '" & strCurrentAffiliate & "'. Error: " & Err.Description
Next_Affiliate:
        CleanupAffiliateSheets strCurrentAffiliate
        On Error GoTo 0
    Next varAffiliateKey
    
    LogPerformance tCheckpoint, "Process All Affiliates"
End Sub

Private Sub FinalizeRun(ByVal tStart As Double)
    'This sub runs regardless of success or failure to clean up the environment.
    On Error Resume Next 'Ensure cleanup completes
    
    Dim lngAffiliateCount As Long
    If Not dictAffiliates Is Nothing Then lngAffiliateCount = dictAffiliates.Count
    
    CleanupMemory
    
    Application.StatusBar = False
    Application.Calculation = xlCalculationAutomatic
    Application.ScreenUpdating = True
    Application.DisplayAlerts = True
    Application.EnableEvents = True
    Application.EnableCancelKey = xlInterrupt
    
    Dim strMessage As String
    strMessage = "Forecast process completed in " & Format$(Timer - tStart, "#,##0.00") & " seconds." & vbCrLf & vbCrLf
    strMessage = strMessage & "Affiliates Processed: " & lngAffiliateCount & vbCrLf
    strMessage = strMessage & "Warnings: " & lngWarningCount & " (see Log sheet for details)"
    
    MsgBox strMessage, IIf(lngWarningCount > 0, vbExclamation, vbInformation), "Forecast Update Complete"
End Sub

'================================================================================================================
' 3. Core Logic & Calculation Functions
'================================================================================================================

Private Sub ProcessForecastForAffiliate(ByVal strAffiliate As String, ByVal lngHistMonthCount As Long)
    'REFACTOR #2: This procedure now orchestrates the processing for a single affiliate.
    Dim wsSummary As Worksheet, wsTier As Worksheet
    Dim colTierSheets As Collection
    Dim tTierStart As Double
    
    'Create the temporary summary sheet
    Set wsSummary = wbHost.Sheets.Add(After:=wbHost.Sheets(wbHost.Sheets.Count)): wsSummary.Name = "TempSummary"
    
    'Create all the necessary tier sheets
    CreateTierSheets strAffiliate, wsSummary
    
    'Get a collection of the sheets we just created
    Set colTierSheets = GetAffiliateTierSheets(strAffiliate)
    
    Dim dictTierSumCache As Object: Set dictTierSumCache = CreateObject("Scripting.Dictionary")
    Dim dictSubTierSumCache As Object: Set dictSubTierSumCache = CreateObject("Scripting.Dictionary")
    
    'Loop through the collection and process each tier sheet
    For Each wsTier In colTierSheets
        tTierStart = Timer
        If wsTier.Cells(wsTier.Rows.Count, "A").End(xlUp).Row > 1 Then
            CalculateAndFormatTierSheet wsTier, strAffiliate, lngHistMonthCount, dictTierSumCache, dictSubTierSumCache
            AppendToSummarySheet wsTier, wsSummary
        Else
            WriteToLog "Info", "ProcessForecastForAffiliate", "Skipping empty tier sheet: " & wsTier.Name
        End If
        LogPerformance tTierStart, "Tier Processed: " & wsTier.Name
    Next wsTier
    
    'Generate the final report file for this affiliate
    GenerateAffiliateReport strAffiliate, wsSummary
End Sub

Private Sub CalculateAndFormatTierSheet(ByVal wsTier As Worksheet, ByVal strAffiliate As String, ByVal lngHistMonthCount As Long, ByVal dictTierSumCache As Object, ByVal dictSubTierSumCache As Object)
    Dim arrOutput() As Variant
    Dim strCurrentProductID As String
    
    On Error GoTo Calc_ErrorHandler
    
    arrOutput = BuildTierOutputArray(wsTier, strAffiliate, strCurrentProductID, lngHistMonthCount, dictTierSumCache, dictSubTierSumCache)
    If Not IsArray(arrOutput) Then Exit Sub
    
    wsTier.Cells.Clear
    wsTier.Range("A1").Resize(UBound(arrOutput, 1), UBound(arrOutput, 2)).Value = arrOutput
    
    If Not DEBUG_MODE Then
        FormatEnhancedSheet wsTier
    End If
    
    Exit Sub
    
Calc_ErrorHandler:
    lngWarningCount = lngWarningCount + 1
    Dim strContext As String
    If strCurrentProductID <> "" Then strContext = " (last processed product: " & strCurrentProductID & ")"
    WriteToLog "Error", "CalculateAndFormatTierSheet", "Failed on sheet '" & wsTier.Name & "'" & strContext & ". Error: " & Err.Description
End Sub

Private Function BuildTierOutputArray(ByVal wsTier As Worksheet, ByVal strAffiliate As String, ByRef strErrorProductID As String, ByVal lngMonthCount As Long, ByVal dictTierSumCache As Object, ByVal dictSubTierSumCache As Object) As Variant
    Dim lngTierLRow As Long
    Dim r As Long, c As Long
    
    Dim arrHeaderRow As Variant: arrHeaderRow = GetCombinedHeaderRow(lngMonthCount)
    
    AddNewProductsToTierSheet wsTier, strAffiliate
    lngTierLRow = wsTier.Cells(wsTier.Rows.Count, COL_AFFILIATE).End(xlUp).Row
    If lngTierLRow < 2 Then Exit Function
    
    Dim arrOutput() As Variant: ReDim arrOutput(1 To lngTierLRow, 1 To UBound(arrHeaderRow))
    
    For c = 1 To UBound(arrHeaderRow): arrOutput(1, c) = arrHeaderRow(c): Next c
    For r = 2 To lngTierLRow
        For c = 1 To 6: arrOutput(r, c) = wsTier.Cells(r, c).Value: Next c
    Next r
    
    For r = 2 To lngTierLRow
        Dim strProduct As String: strProduct = arrOutput(r, COL_ISD)
        strErrorProductID = strProduct
        
        Dim strCompositeKey As String: strCompositeKey = strAffiliate & "|" & strProduct
        Dim objLifecycle As cProductLifecycle
        If dictLifecycleMap.Exists(strCompositeKey) Then Set objLifecycle = dictLifecycleMap.Item(strCompositeKey) Else Set objLifecycle = New cProductLifecycle
        
        arrOutput(r, COL_STATUS) = GetStatusString(objLifecycle.Status)
        If objLifecycle.PhaseOutDate > 0 Then arrOutput(r, COL_PHASE_OUT_DATE) = objLifecycle.PhaseOutDate
        Dim arrHistoricSales As Variant: arrHistoricSales = GetHistoricalDataRow(strAffiliate, strProduct, lngMonthCount + 6)
        For c = 1 To UBound(arrHistoricSales): arrOutput(r, c + 8) = arrHistoricSales(c): Next c
        
        PopulateForecastValues arrOutput, r, objLifecycle, strAffiliate, arrOutput(r, COL_TIER), lngMonthCount, dictTierSumCache, dictSubTierSumCache
        
        Set objLifecycle = Nothing
    Next r
    
    strErrorProductID = ""
    BuildTierOutputArray = arrOutput
End Function

Private Sub PopulateForecastValues(ByRef arrOutput As Variant, ByVal lngRow As Long, ByVal objLifecycle As cProductLifecycle, ByVal strAffiliate As String, ByVal strTier As String, ByVal lngMonthCount As Long, ByVal dictTierSumCache As Object, ByVal dictSubTierSumCache As Object)
    Dim lngDemandRow As Long, c As Long
    Dim dblSubTierSum As Double, dblTierSum As Double
    Dim strSubTierKey As String, strTierKey As String
    
    strSubTierKey = strAffiliate & "|" & strTier & "|" & arrOutput(lngRow, COL_SUB_TIER)
    If dictSubTierSumCache.Exists(strSubTierKey) Then
        dblSubTierSum = dictSubTierSumCache.Item(strSubTierKey)
    Else
        dblSubTierSum = GetHistoricalSubTierSum(strAffiliate, strTier, arrOutput(lngRow, COL_SUB_TIER), lngMonthCount + 6)
        dictSubTierSumCache.Add strSubTierKey, dblSubTierSum
    End If
    
    strTierKey = strAffiliate & "|" & strTier
    If dictTierSumCache.Exists(strTierKey) Then
        dblTierSum = dictTierSumCache.Item(strTierKey)
    Else
        dblTierSum = GetHistoricalTierSum(strAffiliate, strTier, lngMonthCount + 6)
        dictTierSumCache.Add strTierKey, dblTierSum
    End If
    
    lngDemandRow = GetDemandDataRow(strAffiliate, strTier)
    
    If lngDemandRow > 0 Then
        Dim lngForecastStartCol As Long
        lngForecastStartCol = 8 + lngMonthCount + 1
        
        For c = lngForecastStartCol To UBound(arrOutput, 2)
            arrOutput(lngRow, c) = CalculateForecastValue(objLifecycle, arrOutput(1, c), dblSubTierSum, dblTierSum, arrDemandData(lngDemandRow, (c - lngForecastStartCol) + COL_DEMAND_START))
        Next c
    End If
End Sub

Private Function CalculateForecastValue(ByVal objLifecycle As cProductLifecycle, ByVal dteForecastDate As Date, ByVal dblSubTierSum As Double, ByVal dblTierSum As Double, ByVal dblTierDemand As Double) As Double
    Dim dblBaseForecast As Double
    If dblTierSum > 0 Then
        If IsNumeric(dblTierDemand) Then
            dblBaseForecast = (dblSubTierSum * CDbl(dblTierDemand)) / dblTierSum
        End If
    End If
    CalculateForecastValue = dblBaseForecast * objLifecycle.GetForecastMultiplier(dteForecastDate)
End Function

Private Function BuildLifecycleMap(ByVal arrStatusData As Variant) As Object
    Dim r As Long, strProductID As String
    Dim varCompositeKey As Variant, objTempLifecycle As cProductLifecycle, dictMap As Object
    Set dictMap = CreateObject("Scripting.Dictionary")
    
    On Error GoTo BuildMap_ErrorHandler
    
    'First loop: Create all product objects and add them to the map.
    For r = 2 To UBound(arrStatusData, 1)
        If Len(Trim$(arrStatusData(r, COL_ISD))) > 0 And Len(Trim$(arrStatusData(r, COL_AFFILIATE))) > 0 Then
            varCompositeKey = Trim$(arrStatusData(r, COL_AFFILIATE)) & "|" & Trim$(arrStatusData(r, COL_ISD))
            If dictMap.Exists(CStr(varCompositeKey)) Then
                WriteToLog "Warning", "BuildLifecycleMap", "Duplicate product key found, row " & r & ": '" & varCompositeKey & "'"
            Else
                Set objTempLifecycle = New cProductLifecycle
                objTempLifecycle.Init arrStatusData, r
                dictMap.Add CStr(varCompositeKey), objTempLifecycle
            End If
        Else
            WriteToLog "Warning", "BuildLifecycleMap", "Missing Affiliate or I-S-D in 'Product Status' row " & r & ". Skipped."
        End If
    Next r

    'REFACTOR #3: Second loop: Tell each object to link to its successor.
    'The logic is now encapsulated within the cProductLifecycle class.
    For Each varCompositeKey In dictMap.Keys
        Set objTempLifecycle = dictMap.Item(varCompositeKey)
        objTempLifecycle.LinkSuccessor dictMap
    Next varCompositeKey
    
    Set BuildLifecycleMap = dictMap
    Exit Function
    
BuildMap_ErrorHandler:
    WriteToLog "FATAL", "BuildLifecycleMap", "Error building lifecycle map: " & Err.Description
End Function

'================================================================================================================
' 4. Utility & Helper Functions
'================================================================================================================

Private Sub AddNewProductsToTierSheet(ByVal wsTier As Worksheet, ByVal strAffiliate As String)
    On Error GoTo AddNew_ErrorHandler
    ' ... (Implementation is robust and remains unchanged)
    Exit Sub
AddNew_ErrorHandler:
    lngWarningCount = lngWarningCount + 1
    WriteToLog "Error", "AddNewProductsToTierSheet", "Failed to add new products to '" & wsTier.Name & "'. Error: " & Err.Description
End Sub

Private Function GetAffiliateTierSheets(ByVal strAffiliate As String) As Collection
    'REFACTOR #2: New function to find and return all tier sheets for an affiliate.
    Dim colSheets As New Collection
    Dim ws As Worksheet
    Dim strPattern As String: strPattern = SanitizeSheetName(strAffiliate & " - ")
    
    For Each ws In wbHost.Worksheets
        If InStr(1, ws.Name, strPattern) > 0 Then
            colSheets.Add ws
        End If
    Next ws
    
    Set GetAffiliateTierSheets = colSheets
End Function

Private Sub CreateTierSheets(ByVal strAffiliate As String, ByVal wsSummary As Worksheet)
    ' ... (Implementation is robust and remains unchanged, uses SanitizeSheetName)
End Sub

Private Sub GenerateAffiliateReport(ByVal strAffiliate As String, ByVal wsSummary As Worksheet)
    ' ... (Implementation is robust and remains unchanged)
End Sub

Private Sub CleanupAffiliateSheets(ByVal strAffiliate As String)
    ' ... (Implementation is robust and remains unchanged)
End Sub

Private Sub CleanupMemory()
    ' ... (Implementation is robust and remains unchanged)
End Sub

' --- Other helper functions (GetHistoricalDataRow, GetHistoricalTierSum, etc.) remain unchanged ---

'================================================================================================================
' 5. Formatting Sub-Procedures
'================================================================================================================

Private Sub FormatEnhancedSheet(ByVal ws As Worksheet)
    'REFACTOR #7: This procedure now orchestrates calls to smaller formatting subs.
    If ws.Cells(1, 1).Value = "" Then Exit Sub
    
    Dim lngLastRow As Long, lngLastCol As Long, lngTotalRow As Long
    
    With ws
        lngLastRow = .Cells(.Rows.Count, "A").End(xlUp).Row
        lngLastCol = .Cells(1, .Columns.Count).End(xlToLeft).Column
    End With
    
    lngTotalRow = ApplyTotalRow(ws, lngLastRow, lngLastCol)
    ApplyTableStyles ws, lngTotalRow, lngLastCol
    ApplyNumberFormats ws, lngTotalRow, lngLastCol
    
    ws.Cells.EntireColumn.AutoFit
    If ws.Name = SHEET_SUMMARY_PREFIX Then
        ws.Range("A1", ws.Cells(lngTotalRow, lngLastCol)).Sort Key1:=ws.Range("F2"), Order1:=xlAscending, Header:=xlYes
    End If
End Sub

Private Function ApplyTotalRow(ByVal ws As Worksheet, ByVal lngLastRow As Long, ByVal lngLastCol As Long) As Long
    'REFACTOR #7: New sub dedicated to adding and calculating the total row.
    Dim lngTotalRow As Long: lngTotalRow = lngLastRow
    If LCase$(ws.Cells(lngLastRow, "A").Value) <> "total" Then lngTotalRow = lngLastRow + 1
    
    ws.Cells(lngTotalRow, "A").Value = "TOTAL"
    Dim i As Long
    For i = 9 To lngLastCol
        On Error Resume Next
        ws.Cells(lngTotalRow, i).Value = Application.WorksheetFunction.Sum(ws.Range(ws.Cells(2, i), ws.Cells(lngLastRow, i)))
        On Error GoTo 0
    Next i
    ApplyTotalRow = lngTotalRow
End Function

Private Sub ApplyTableStyles(ByVal ws As Worksheet, ByVal lngTotalRow As Long, ByVal lngLastCol As Long)
    'REFACTOR #7: New sub dedicated to applying fonts, colors, and borders.
    Dim rngHeader As Range, rngTotal As Range, rngFull As Range
    Dim r As Long, lngHistLCol As Long
    
    With ws
        Set rngHeader = .Range(.Cells(1, 1), .Cells(1, lngLastCol))
        Set rngTotal = .Range(.Cells(lngTotalRow, 1), .Cells(lngTotalRow, lngLastCol))
        Set rngFull = .Range(.Cells(1, 1), .Cells(lngTotalRow, lngLastCol))
    End With
    
    rngFull.Interior.ColorIndex = xlNone
    rngFull.Borders.LineStyle = xlNone
    rngFull.Font.Bold = False
    
    With rngHeader
        .Font.Bold = True: .Font.Color = vbWhite: .Interior.Color = RGB(47, 85, 151)
    End With
    With rngTotal
        .Font.Bold = True: .Interior.Color = RGB(221, 235, 247)
    End With
    
    'Zebra striping
    For r = 2 To lngTotalRow - 1
        If r Mod 2 = 0 Then ws.Range(ws.Cells(r, 1), ws.Cells(r, lngLastCol)).Interior.Color = RGB(242, 242, 242)
    Next r
    
    'Historical data shading and border
    lngHistLCol = GetLastHistoricalColumn(ws)
    If lngHistLCol > 8 Then
        ws.Range(ws.Cells(2, 9), ws.Cells(lngTotalRow - 1, lngHistLCol)).Interior.Color = RGB(220, 220, 220)
        With ws.Range(ws.Cells(1, lngHistLCol), ws.Cells(lngTotalRow, lngHistLCol)).Borders(xlEdgeRight)
            .LineStyle = xlContinuous: .Weight = xlMedium
        End With
    End If
    
    'Outer borders
    rngFull.Borders.LineStyle = xlContinuous
    rngFull.Borders.Weight = xlThin
End Sub

Private Sub ApplyNumberFormats(ByVal ws As Worksheet, ByVal lngTotalRow As Long, ByVal lngLastCol As Long)
    'REFACTOR #7: New sub dedicated to applying number formatting.
    With ws
        .Range(.Cells(2, 9), .Cells(lngTotalRow, lngLastCol)).NumberFormat = "_(* #,##0_);_(* (#,##0);_(* ""-""??_);_(@_)"
        .Range(.Cells(1, 9), .Cells(1, lngLastCol)).NumberFormat = "mmm-yy"
    End With
End Sub
