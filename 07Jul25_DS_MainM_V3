'@Folder("Forecasting")
Option Explicit

'================================================================================================
' FORECASTING ENGINE MODULE (M_Forecasting)
' V23.2: Duplicate Declaration Fix
'      - Resolved "Duplicate declaration" compile error in ComputeBaseForecasts
'        by moving the variable declaration to a higher scope.
'
' Author:      Ayush Goyal
' Date:        07-Jul-2025
'================================================================================================

'--- Private Module-Level Variables ---
Private wbHost As Workbook
Private wsLog As Worksheet
Private lngWarningCount As Long
Private dictStatusMap As Object
Private arrStatusData As Variant
Private arrHistoryData As Variant
Private arrDemandData As Variant
Private dictLifecycleMap As Object
Private dictAffiliates As Object
Private dictKeyFigures As Object
Private dictHistoryCache As Object

'================================================================================================
' 1. MAIN PUBLIC ORCHESTRATOR
'================================================================================================

Public Sub UpdateForecast_V8()
    Dim tStart As Double: tStart = Timer

    If Not InitializeRun() Then GoTo Main_Exit
    If Not LoadAndValidateData() Then GoTo Main_Exit
    
    BuildCachesAndMaps
    ProcessAllAffiliates

Main_Exit:
    FinalizeRun tStart
End Sub


'================================================================================================
' 2. CORE WORKFLOW STAGES
'================================================================================================

Private Function InitializeRun() As Boolean
    Dim tCheckpoint As Double: tCheckpoint = Timer
    On Error GoTo Init_ErrorHandler
    
    SetupApplication
    
    Set wbHost = ThisWorkbook
    InitializeStatusMap
    lngWarningCount = 0
    
    '--- Safely re-create the log sheet ---
    Application.DisplayAlerts = False
    On Error Resume Next
    wbHost.Sheets(SHEET_LOG).Delete
    On Error GoTo Init_ErrorHandler
    Application.DisplayAlerts = True
    
    Set wsLog = wbHost.Sheets.Add(After:=wbHost.Sheets(wbHost.Sheets.Count))
    InitializeLogSheet wsLog
    
    LogPerformance tCheckpoint, "Initialize Environment"
    InitializeRun = True
    Exit Function

Init_ErrorHandler:
    MsgBox "A critical error occurred during initialization: " & Err.Description, vbCritical, "Initialization Failed"
    InitializeRun = False
End Function

Private Function LoadAndValidateData() As Boolean
    Dim tCheckpoint As Double: tCheckpoint = Timer
    On Error GoTo Load_ErrorHandler
    
    Application.StatusBar = "Loading and validating source data..."
    
    '--- Validate sheet existence before attempting to load ---
    If Not SheetExists(SHEET_STATUS) Then Err.Raise 515, , "Required sheet '" & SHEET_STATUS & "' not found."
    If Not SheetExists(SHEET_HISTORY) Then Err.Raise 516, , "Required sheet '" & SHEET_HISTORY & "' not found."
    If Not SheetExists(SHEET_DEMAND) Then Err.Raise 517, , "Required sheet '" & SHEET_DEMAND & "' not found."
    
    '--- Load data into variant arrays ---
    arrStatusData = LoadDataToArray(wbHost.Sheets(SHEET_STATUS))
    arrHistoryData = LoadDataToArray(wbHost.Sheets(SHEET_HISTORY))
    arrDemandData = LoadDataToArray(wbHost.Sheets(SHEET_DEMAND))
    
    WriteToLog ltInfo, "LoadAndValidateData", "All source data loaded and validated."
    LogPerformance tCheckpoint, "Load & Validate Data"
    LoadAndValidateData = True
    Exit Function

Load_ErrorHandler:
    Dim strErrorMsg As String: strErrorMsg = "Failed to load source sheets. " & vbCrLf & Err.Description
    WriteToLog ltFatal, "LoadAndValidateData", strErrorMsg, Err.Number
    MsgBox strErrorMsg, vbCritical, "Process Halted"
    LoadAndValidateData = False
End Function

Private Sub BuildCachesAndMaps()
    Dim tCheckpoint As Double: tCheckpoint = Timer
    Application.StatusBar = "Building data caches and maps..."
    
    Set dictLifecycleMap = BuildLifecycleMap(arrStatusData)
    Set dictAffiliates = GetUniqueValues(arrDemandData, DF_AFFILIATE_COL)
    Set dictKeyFigures = GetUniqueValues(arrDemandData, DF_KEY_FIGURE_COL)
    BuildHistoryCache
    
    LogPerformance tCheckpoint, "Build Caches and Maps"
End Sub

Private Sub BuildHistoryCache()
    Set dictHistoryCache = CreateObject("Scripting.Dictionary")
    Dim r As Long, c As Long
    Dim strKey As String
    Dim dictMonthlyValues As Object
    
    For r = 2 To UBound(arrHistoryData, 1)
        ' Key: Affiliate|KeyFigure|LocalItemNbr
        strKey = arrHistoryData(r, HS_AFFILIATE_COL) & "|" & arrHistoryData(r, HS_KEY_FIGURE_COL) & "|" & arrHistoryData(r, HS_LOCAL_ITEM_NBR_COL)
        
        If Not dictHistoryCache.Exists(strKey) Then
            Set dictMonthlyValues = CreateObject("Scripting.Dictionary")
            For c = HS_START_OF_MONTHS_COL To UBound(arrHistoryData, 2)
                dictMonthlyValues.Add CDate(arrHistoryData(1, c)), arrHistoryData(r, c)
            Next c
            dictHistoryCache.Add strKey, dictMonthlyValues
        End If
    Next r
End Sub

Private Sub ProcessAllAffiliates()
    Dim varAffiliate As Variant, strAffiliate As String
    Dim lngCounter As Long, lngTotal As Long
    Dim tCheckpoint As Double: tCheckpoint = Timer
    
    lngTotal = dictAffiliates.Count
    If lngTotal = 0 Then
        WriteToLog ltWarning, "ProcessAllAffiliates", "No affiliates found in Demand Forecast sheet."
        Exit Sub
    End If
    
    For Each varAffiliate In dictAffiliates.Keys
        strAffiliate = CStr(varAffiliate)
        lngCounter = lngCounter + 1
        On Error GoTo Affiliate_ErrorHandler
        
        Application.StatusBar = "Processing Affiliate: " & strAffiliate & " (" & lngCounter & " of " & lngTotal & ")..."
        WriteToLog ltInfo, "ProcessAllAffiliates", "Starting: " & strAffiliate
        
        ProcessForecastForAffiliate strAffiliate
        
        GoTo Next_Affiliate
Affiliate_ErrorHandler:
        lngWarningCount = lngWarningCount + 1
        WriteToLog ltError, "ProcessAllAffiliates", "A critical error occurred processing affiliate '" & strAffiliate & "'.", Err.Number, Err.Description
        Resume Next_Affiliate
Next_Affiliate:
        On Error GoTo 0
    Next varAffiliate
    
    LogPerformance tCheckpoint, "Process All Affiliates"
End Sub

Private Sub FinalizeRun(ByVal tStart As Double)
    On Error Resume Next
    
    CleanupMemory
    
    Application.StatusBar = False
    Application.Calculation = xlCalculationAutomatic
    Application.ScreenUpdating = True
    Application.DisplayAlerts = True
    
    Dim strMessage As String
    strMessage = "Forecast process completed in " & Format$(Timer - tStart, "#,##0.00") & " seconds." & vbCrLf & vbCrLf
    strMessage = strMessage & "Affiliates Processed: " & dictAffiliates.Count & vbCrLf
    strMessage = strMessage & "Warnings: " & lngWarningCount & " (see Log sheet for details)"
    
    MsgBox strMessage, IIf(lngWarningCount > 0, vbExclamation, vbInformation), "Forecast Update Complete"
    
    On Error GoTo 0
End Sub

'================================================================================================
' 3. FORECAST CALCULATION LOGIC
'================================================================================================

Private Sub ProcessForecastForAffiliate(ByVal strAffiliate As String)
    ' --- Stage 1: Calculate all forecast values and store in memory ---
    InitializeForecastValues strAffiliate
    ComputeBaseForecasts strAffiliate
    ApplyLifecycleAdjustments strAffiliate
    
    ' --- Stage 2: Create the report workbook and generate all sheets from stored values ---
    GenerateAffiliateReport strAffiliate
End Sub

Private Sub InitializeForecastValues(ByVal strAffiliate As String)
    Dim objLifecycle As cProductLifecycle
    Dim varProductKey As Variant
    
    For Each varProductKey In dictLifecycleMap.Keys
        Set objLifecycle = dictLifecycleMap.Item(varProductKey)
        If objLifecycle.Affiliate = strAffiliate Then
            Set objLifecycle.ForecastValues = CreateObject("Scripting.Dictionary")
        End If
    Next varProductKey
End Sub

Private Sub ComputeBaseForecasts(ByVal strAffiliate As String)
    Dim objLifecycle As cProductLifecycle
    Dim varProductKey As Variant, varKeyFigure As Variant
    Dim monthIndex As Long
    Dim dteForecastMonth As Date
    Dim dictTierSumCache As Object: Set dictTierSumCache = CreateObject("Scripting.Dictionary")
    
    For Each varProductKey In dictLifecycleMap.Keys
        Set objLifecycle = dictLifecycleMap.Item(varProductKey)
        If objLifecycle.Affiliate = strAffiliate Then
            For Each varKeyFigure In dictKeyFigures.Keys
                Dim strKeyFigure As String: strKeyFigure = CStr(varKeyFigure)
                Dim dblHistSubTierSum As Double, dblHistTierSum As Double
                Dim tierSumKey As String
                
                ' --- Get historical sum for the entire tier (use cache if available) ---
                tierSumKey = strAffiliate & "|" & objLifecycle.ForecastTier & "|" & strKeyFigure
                If dictTierSumCache.Exists(tierSumKey) Then
                    dblHistTierSum = dictTierSumCache.Item(tierSumKey)
                Else
                    dblHistTierSum = GetHistoricalSum(strAffiliate, objLifecycle.ForecastTier, "", strKeyFigure)
                    dictTierSumCache.Add tierSumKey, dblHistTierSum
                End If
                
                ' --- If tier has history, calculate for sub-tier and then compute forecast ---
                If dblHistTierSum > 0 Then
                    dblHistSubTierSum = GetHistoricalSum(strAffiliate, objLifecycle.ForecastTier, objLifecycle.ForecastSubTier, strKeyFigure)
                    
                    For monthIndex = 1 To UBound(arrDemandData, 2) - DF_START_OF_MONTHS_COL + 1
                        dteForecastMonth = arrDemandData(1, DF_START_OF_MONTHS_COL + monthIndex - 1)
                        Dim dblDemandTierValue As Double: dblDemandTierValue = GetDemandValue(strAffiliate, objLifecycle.ForecastTier, strKeyFigure, dteForecastMonth)
                        Dim dblBaseForecast As Double
                        
                        dblBaseForecast = (dblHistSubTierSum / dblHistTierSum) * dblDemandTierValue
                        
                        objLifecycle.ForecastValues.Add strKeyFigure & "|" & dteForecastMonth, dblBaseForecast
                    Next monthIndex
                Else
                    ' --- If tier has no history, all forecasts for this key figure are zero ---
                     For monthIndex = 1 To UBound(arrDemandData, 2) - DF_START_OF_MONTHS_COL + 1
                        dteForecastMonth = arrDemandData(1, DF_START_OF_MONTHS_COL + monthIndex - 1)
                        objLifecycle.ForecastValues.Add strKeyFigure & "|" & dteForecastMonth, 0
                    Next monthIndex
                End If
            Next varKeyFigure
        End If
    Next varProductKey
End Sub

Private Sub ApplyLifecycleAdjustments(ByVal strAffiliate As String)
    Dim objLifecycle As cProductLifecycle
    Dim varProductKey As Variant
    
    For Each varProductKey In dictLifecycleMap.Keys
        Set objLifecycle = dictLifecycleMap.Item(varProductKey)
        If objLifecycle.Affiliate = strAffiliate Then
            objLifecycle.LinkAndTransferSuccessorForecast dictLifecycleMap
        End If
    Next varProductKey
End Sub


'================================================================================================
' 4. REPORT GENERATION
'================================================================================================

Private Sub GenerateAffiliateReport(ByVal strAffiliate As String)
    Dim wbReport As Workbook, ws As Worksheet
    Dim varKeyFigure As Variant, varTier As Variant
    Dim dictTiers As Object, dictSheetToKeyFigureMap As Object
    Set dictSheetToKeyFigureMap = CreateObject("Scripting.Dictionary")
    
    Set wbReport = Workbooks.Add
    
    For Each varKeyFigure In dictKeyFigures.Keys
        Set ws = wbReport.Sheets.Add(Before:=wbReport.Sheets(1))
        Dim sheetName As String: sheetName = SanitizeSheetName("Summary - " & CStr(varKeyFigure))
        ws.Name = sheetName
        dictSheetToKeyFigureMap.Add sheetName, CStr(varKeyFigure)
    Next varKeyFigure
    
    Application.DisplayAlerts = False
    wbReport.Sheets("Sheet1").Delete
    Application.DisplayAlerts = True

    Set dictTiers = GetUniqueTiersForAffiliate(strAffiliate)
    
    For Each varTier In dictTiers.Keys
        Set ws = wbReport.Sheets.Add(After:=wbReport.Sheets(wbReport.Sheets.Count))
        ws.Name = SanitizeSheetName(CStr(varTier))
        PopulateTierSheet ws, strAffiliate, CStr(varTier)
        FormatTierSheet ws
    Next varTier
    
    PopulateSummarySheets wbReport, strAffiliate, dictSheetToKeyFigureMap
    
    If Not DEBUG_MODE Then
        Application.StatusBar = "Saving final report for " & strAffiliate & "..."
        Dim strFilePath As String
        strFilePath = GetOutputFilePath(wbHost.Path, strAffiliate)
        wbReport.SaveAs strFilePath
        wbReport.Close SaveChanges:=False
        WriteToLog ltInfo, "GenerateAffiliateReport", "Report saved to " & strFilePath
    End If
End Sub

Private Sub PopulateTierSheet(ByVal ws As Worksheet, ByVal strAffiliate As String, ByVal strTier As String)
    Dim arrOutput() As Variant, arrHeader() As Variant
    Dim monthIndex As Long, colIndex As Long
    Dim objLifecycle As cProductLifecycle
    Dim varKeyFigure As Variant
    Dim colProducts As Collection
    Dim numHistMonths As Long, numFcstMonths As Long
    Dim outputRowIndex As Long, subtotalStartRow As Long
    
    Set colProducts = GetProductsForTier(strAffiliate, strTier)
    If colProducts.Count = 0 Then Exit Sub
    
    numHistMonths = UBound(arrHistoryData, 2) - HS_START_OF_MONTHS_COL + 1
    numFcstMonths = UBound(arrDemandData, 2) - DF_START_OF_MONTHS_COL + 1
    
    ReDim arrHeader(1 To 9 + numHistMonths + numFcstMonths)
    
    arrHeader(1) = "Affiliate": arrHeader(2) = "Forecast Tier": arrHeader(3) = "Forecast Sub-Tier"
    arrHeader(4) = "Key Figures": arrHeader(5) = "Local Item Nbr": arrHeader(6) = "Desc"
    arrHeader(7) = "I-S-D": arrHeader(8) = "Status": arrHeader(9) = "Phase Out Month"
    
    colIndex = 10
    For monthIndex = 1 To numHistMonths
        arrHeader(colIndex) = Format$(arrHistoryData(1, HS_START_OF_MONTHS_COL + monthIndex - 1), "mmm-yy")
        colIndex = colIndex + 1
    Next monthIndex
    For monthIndex = 1 To numFcstMonths
        arrHeader(colIndex) = Format$(arrDemandData(1, DF_START_OF_MONTHS_COL + monthIndex - 1), "mmm-yy")
        colIndex = colIndex + 1
    Next monthIndex
    
    ReDim arrOutput(1 To (colProducts.Count * dictKeyFigures.Count) + dictKeyFigures.Count, 1 To UBound(arrHeader))
    
    outputRowIndex = 1
    
    For Each varKeyFigure In dictKeyFigures.Keys
        subtotalStartRow = outputRowIndex
        
        For Each objLifecycle In colProducts
            arrOutput(outputRowIndex, 1) = objLifecycle.Affiliate
            arrOutput(outputRowIndex, 2) = objLifecycle.ForecastTier
            arrOutput(outputRowIndex, 3) = objLifecycle.ForecastSubTier
            arrOutput(outputRowIndex, 4) = CStr(varKeyFigure)
            arrOutput(outputRowIndex, 5) = objLifecycle.LocalItemNbr
            arrOutput(outputRowIndex, 6) = objLifecycle.Description
            arrOutput(outputRowIndex, 7) = objLifecycle.ISD
            arrOutput(outputRowIndex, 8) = GetStatusString(objLifecycle.Status)
            If objLifecycle.PhaseOutDate > 0 Then arrOutput(outputRowIndex, 9) = objLifecycle.PhaseOutDate
            
            colIndex = 10
            ' Populate Historical Data
            Dim histKey As String: histKey = objLifecycle.Affiliate & "|" & CStr(varKeyFigure) & "|" & objLifecycle.LocalItemNbr
            For monthIndex = 1 To numHistMonths
                Dim dteHistMonth As Date: dteHistMonth = arrHistoryData(1, HS_START_OF_MONTHS_COL + monthIndex - 1)
                If dictHistoryCache.Exists(histKey) Then
                    If dictHistoryCache.Item(histKey).Exists(dteHistMonth) Then
                        arrOutput(outputRowIndex, colIndex) = dictHistoryCache.Item(histKey).Item(dteHistMonth)
                    End If
                End If
                colIndex = colIndex + 1
            Next monthIndex
            
            ' Populate Forecast Data
            For monthIndex = 1 To numFcstMonths
                Dim dteFcstMonth As Date: dteFcstMonth = arrDemandData(1, DF_START_OF_MONTHS_COL + monthIndex - 1)
                Dim fcstKey As String: fcstKey = CStr(varKeyFigure) & "|" & dteFcstMonth
                If objLifecycle.ForecastValues.Exists(fcstKey) Then
                    arrOutput(outputRowIndex, colIndex) = objLifecycle.ForecastValues.Item(fcstKey) * objLifecycle.GetForecastMultiplier(dteFcstMonth)
                End If
                colIndex = colIndex + 1
            Next monthIndex
            outputRowIndex = outputRowIndex + 1
        Next objLifecycle
        
        arrOutput(outputRowIndex, 1) = "TOTAL"
        arrOutput(outputRowIndex, 2) = strTier
        arrOutput(outputRowIndex, 4) = CStr(varKeyFigure)
        For colIndex = 10 To UBound(arrOutput, 2)
            Dim monthlyTotal As Double: monthlyTotal = 0
            Dim productRow As Long
            For productRow = subtotalStartRow To outputRowIndex - 1
                If IsNumeric(arrOutput(productRow, colIndex)) Then
                    monthlyTotal = monthlyTotal + CDbl(arrOutput(productRow, colIndex))
                End If
            Next productRow
            arrOutput(outputRowIndex, colIndex) = monthlyTotal
        Next colIndex
        outputRowIndex = outputRowIndex + 1
        
    Next varKeyFigure
    
    ws.Range("A1").Resize(1, UBound(arrHeader)).Value = arrHeader
    ws.Range("A2").Resize(outputRowIndex - 1, UBound(arrHeader)).Value = arrOutput
End Sub

Private Sub FormatTierSheet(ByVal ws As Worksheet)
    Dim lastRow As Long, lastCol As Long
    Dim dataRange As Range
    Dim rowIndex As Long, histColEnd As Long
    
    lastRow = ws.Cells(ws.Rows.Count, "A").End(xlUp).row
    If lastRow <= 1 Then Exit Sub
    
    lastCol = ws.Cells(1, ws.Columns.Count).End(xlToLeft).Column
    histColEnd = 9 + (UBound(arrHistoryData, 2) - HS_START_OF_MONTHS_COL + 1)
    
    Set dataRange = ws.Range("A1").Resize(lastRow, lastCol)
    
    ' Format Static and Forecast Headers (Dark Blue)
    With Union(ws.Range("A1:I1"), ws.Range(ws.Cells(1, histColEnd + 1), ws.Cells(1, lastCol)))
        .Font.Bold = True
        .Font.Color = vbWhite
        .Interior.Color = RGB(0, 32, 96)
        .VerticalAlignment = xlCenter
    End With
    
    ' Format Historical Headers (Gray)
    With ws.Range(ws.Cells(1, 10), ws.Cells(1, histColEnd))
        .Font.Bold = True
        .Font.Color = vbBlack
        .Interior.Color = RGB(217, 217, 217)
        .VerticalAlignment = xlCenter
    End With
    
    ' Format Historical Data Area (Light Fill)
    ws.Range(ws.Cells(2, 10), ws.Cells(lastRow, histColEnd)).Interior.Color = RGB(242, 242, 242)
    
    ' Format Subtotal Rows
    For rowIndex = 2 To lastRow
        If ws.Cells(rowIndex, 1).Value = "TOTAL" Then
            With ws.Range(ws.Cells(rowIndex, 1), ws.Cells(rowIndex, lastCol))
                .Font.Bold = True
                .Interior.Color = RGB(220, 230, 241) ' Light Blue
            End With
        End If
    Next rowIndex
    
    ws.Range("J2", ws.Cells(lastRow, lastCol)).NumberFormat = "#,##0"
    ws.Columns("I").NumberFormat = "dd/mm/yyyy"
    
    With dataRange.Borders
        .LineStyle = xlContinuous
        .Weight = xlThin
    End With
    
    ws.Columns.AutoFit
    ws.Activate
    ws.Rows(2).Select
    ActiveWindow.FreezePanes = True
    ws.Cells(1, 1).Select
End Sub

Private Sub FormatSummarySheet(ByVal ws As Worksheet)
    Dim lastRow As Long, lastCol As Long
    Dim dataRange As Range, headerRange As Range

    lastRow = ws.Cells(ws.Rows.Count, "A").End(xlUp).row
    If lastRow <= 1 Then Exit Sub
    
    lastCol = ws.Cells(1, ws.Columns.Count).End(xlToLeft).Column
    
    Set headerRange = ws.Range("A1").Resize(1, lastCol)
    Set dataRange = ws.Range("A1").Resize(lastRow, lastCol)
    
    With headerRange
        .Font.Bold = True
        .Font.Color = vbWhite
        .Interior.Color = RGB(0, 32, 96)
        .VerticalAlignment = xlCenter
    End With
    
    ws.Range(ws.Cells(2, 9), ws.Cells(lastRow, lastCol)).NumberFormat = "#,##0"
    ws.Columns("H").NumberFormat = "dd/mm/yyyy"
    
    With dataRange.Borders
        .LineStyle = xlContinuous
        .Weight = xlThin
    End With
    
    ws.Columns.AutoFit
    ws.Activate
    ws.Rows(2).Select
    ActiveWindow.FreezePanes = True
    ws.Cells(1, 1).Select
End Sub


Private Sub PopulateSummarySheets(ByVal wbReport As Workbook, ByVal strAffiliate As String, ByVal dictMap As Object)
    Dim ws As Worksheet
    For Each ws In wbReport.Worksheets
        If dictMap.Exists(ws.Name) Then
            Dim strFullKeyFigure As String
            strFullKeyFigure = dictMap.Item(ws.Name)
            
            Dim arrHeader As Variant
            Dim numForecastMonths As Long: numForecastMonths = UBound(arrDemandData, 2) - DF_START_OF_MONTHS_COL + 1
            ReDim arrHeader(1 To 8 + numForecastMonths)
            arrHeader(1) = "Affiliate": arrHeader(2) = "Forecast Tier": arrHeader(3) = "Forecast Sub-Tier"
            arrHeader(4) = "Local Item Nbr": arrHeader(5) = "Desc": arrHeader(6) = "I-S-D"
            arrHeader(7) = "Status": arrHeader(8) = "Phase Out Month"
            
            Dim monthIndex As Long
            For monthIndex = 1 To numForecastMonths
                arrHeader(8 + monthIndex) = Format$(arrDemandData(1, DF_START_OF_MONTHS_COL + monthIndex - 1), "mmm-yy")
            Next monthIndex
            ws.Range("A1").Resize(1, UBound(arrHeader)).Value = arrHeader
            
            Dim lngRow As Long: lngRow = 2
            Dim objLifecycle As cProductLifecycle
            Dim varKey As Variant
            For Each varKey In dictLifecycleMap.Keys
                Set objLifecycle = dictLifecycleMap.Item(varKey)
                If objLifecycle.Affiliate = strAffiliate Then
                    ws.Cells(lngRow, 1).Value = objLifecycle.Affiliate: ws.Cells(lngRow, 2).Value = objLifecycle.ForecastTier
                    ws.Cells(lngRow, 3).Value = objLifecycle.ForecastSubTier: ws.Cells(lngRow, 4).Value = objLifecycle.LocalItemNbr
                    ws.Cells(lngRow, 5).Value = objLifecycle.Description: ws.Cells(lngRow, 6).Value = objLifecycle.ISD
                    ws.Cells(lngRow, 7).Value = GetStatusString(objLifecycle.Status)
                    If objLifecycle.PhaseOutDate > 0 Then ws.Cells(lngRow, 8).Value = objLifecycle.PhaseOutDate
                    
                    For monthIndex = 1 To numForecastMonths
                        Dim dteForecastMonth As Date: dteForecastMonth = arrDemandData(1, DF_START_OF_MONTHS_COL + monthIndex - 1)
                        Dim forecastKey As String: forecastKey = strFullKeyFigure & "|" & dteForecastMonth
                        
                        If objLifecycle.ForecastValues.Exists(forecastKey) Then
                            ws.Cells(lngRow, 8 + monthIndex).Value = objLifecycle.ForecastValues.Item(forecastKey) * objLifecycle.GetForecastMultiplier(dteForecastMonth)
                        End If
                    Next monthIndex
                    lngRow = lngRow + 1
                End If
            Next varKey
            
            FormatSummarySheet ws
        End If
    Next ws
End Sub

'================================================================================================
' 5. DATA RETRIEVAL & CACHING
'================================================================================================

Private Function BuildLifecycleMap(ByVal arrStatus As Variant) As Object
    Dim dictMap As Object: Set dictMap = CreateObject("Scripting.Dictionary")
    Dim rowIndex As Long, obj As cProductLifecycle
    
    For rowIndex = 2 To UBound(arrStatus, 1)
        Dim strKey As String: strKey = BuildCompositeKey(arrStatus(rowIndex, PS_AFFILIATE_COL), arrStatus(rowIndex, PS_ISD_COL))
        If Not dictMap.Exists(strKey) Then
            Set obj = New cProductLifecycle
            obj.Init arrStatus, rowIndex
            dictMap.Add strKey, obj
        Else
            lngWarningCount = lngWarningCount + 1
            WriteToLog ltWarning, "BuildLifecycleMap", "Duplicate product key found in Product Status sheet. First instance used.", , "Key: " & strKey & " on row " & rowIndex
        End If
    Next rowIndex
    Set BuildLifecycleMap = dictMap
End Function

Private Function GetHistoricalSum(strAffiliate As String, strTier As String, strSubTier As String, strKeyFigure As String) As Double
    Dim rowIndex As Long, dblSum As Double
    For rowIndex = 2 To UBound(arrHistoryData, 1)
        If arrHistoryData(rowIndex, HS_AFFILIATE_COL) = strAffiliate And _
           arrHistoryData(rowIndex, HS_TIER_COL) = strTier And _
           arrHistoryData(rowIndex, HS_KEY_FIGURE_COL) = strKeyFigure Then
           
            If strSubTier = "" Or arrHistoryData(rowIndex, HS_SUB_TIER_COL) = strSubTier Then
                Dim colIndex As Long
                For colIndex = HS_START_OF_MONTHS_COL To UBound(arrHistoryData, 2)
                    If IsNumeric(arrHistoryData(rowIndex, colIndex)) Then
                        dblSum = dblSum + CDbl(arrHistoryData(rowIndex, colIndex))
                    End If
                Next colIndex
            End If
        End If
    Next rowIndex
    GetHistoricalSum = dblSum
End Function

Private Function GetDemandValue(strAffiliate As String, strTier As String, strKeyFigure As String, dteMonth As Date) As Double
    Dim rowIndex As Long, colIndex As Long
    For colIndex = DF_START_OF_MONTHS_COL To UBound(arrDemandData, 2)
        If IsDate(arrDemandData(1, colIndex)) Then
            If CDate(arrDemandData(1, colIndex)) = dteMonth Then Exit For
        End If
    Next colIndex
    If colIndex > UBound(arrDemandData, 2) Then Exit Function
    
    For rowIndex = 2 To UBound(arrDemandData, 1)
        If arrDemandData(rowIndex, DF_AFFILIATE_COL) = strAffiliate And _
           arrDemandData(rowIndex, DF_TIER_COL) = strTier And _
           arrDemandData(rowIndex, DF_KEY_FIGURE_COL) = strKeyFigure Then
            If IsNumeric(arrDemandData(rowIndex, colIndex)) Then
                GetDemandValue = CDbl(arrDemandData(rowIndex, colIndex))
            End If
            Exit Function
        End If
    Next rowIndex
End Function

Private Function GetProductsForTier(strAffiliate As String, strTier As String) As Collection
    Set GetProductsForTier = New Collection
    Dim varKey As Variant, obj As cProductLifecycle
    For Each varKey In dictLifecycleMap.Keys
        Set obj = dictLifecycleMap.Item(varKey)
        If obj.Affiliate = strAffiliate And obj.ForecastTier = strTier Then
            GetProductsForTier.Add obj
        End If
    Next varKey
End Function

Private Function GetUniqueTiersForAffiliate(strAffiliate As String) As Object
    Set GetUniqueTiersForAffiliate = CreateObject("Scripting.Dictionary")
    Dim rowIndex As Long
    For rowIndex = 2 To UBound(arrDemandData, 1)
        If arrDemandData(rowIndex, DF_AFFILIATE_COL) = strAffiliate Then
            Dim strTier As String: strTier = arrDemandData(rowIndex, DF_TIER_COL)
            If Not GetUniqueTiersForAffiliate.Exists(strTier) Then
                GetUniqueTiersForAffiliate.Add strTier, 1
            End If
        End If
    Next rowIndex
End Function

'================================================================================================
' 6. UTILITY & HELPER FUNCTIONS
'================================================================================================

Private Sub SetupApplication()
    Application.ScreenUpdating = False
    Application.DisplayAlerts = False
    Application.Calculation = xlCalculationManual
End Sub

Private Function SheetExists(ByVal sheetName As String) As Boolean
    Dim ws As Worksheet
    On Error Resume Next
    Set ws = wbHost.Sheets(sheetName)
    On Error GoTo 0
    SheetExists = Not ws Is Nothing
End Function

Private Function LoadDataToArray(ByVal ws As Worksheet) As Variant
    If ws Is Nothing Then Exit Function
    Dim lRow As Long: lRow = ws.Cells(ws.Rows.Count, "A").End(xlUp).row
    Dim lCol As Long: lCol = ws.Cells(1, ws.Columns.Count).End(xlToLeft).Column
    If lRow > 1 And lCol > 0 Then LoadDataToArray = ws.Range("A1", ws.Cells(lRow, lCol)).Value
End Function

Public Function BuildCompositeKey(ByVal keyPart1 As String, ByVal keyPart2 As String) As String
    Const SEPARATOR As String = "|"
    BuildCompositeKey = Trim$(keyPart1) & SEPARATOR & Trim$(keyPart2)
End Function

Private Function GetUniqueValues(arrData As Variant, ByVal lngCol As Long) As Object
    Dim dict As Object: Set dict = CreateObject("Scripting.Dictionary")
    dict.CompareMode = vbTextCompare
    Dim rowIndex As Long
    For rowIndex = 2 To UBound(arrData, 1)
        If Not IsEmpty(arrData(rowIndex, lngCol)) Then
            If Not dict.Exists(arrData(rowIndex, lngCol)) Then
                dict.Add arrData(rowIndex, lngCol), 1
            End If
        End If
    Next rowIndex
    Set GetUniqueValues = dict
End Function

Private Function SanitizeSheetName(ByVal strName As String) As String
    Dim sanitizedString As String
    sanitizedString = strName
    sanitizedString = Replace(sanitizedString, "/", "-")
    sanitizedString = Replace(sanitizedString, "\", "-")
    sanitizedString = Replace(sanitizedString, "?", "")
    sanitizedString = Replace(sanitizedString, "*", "")
    sanitizedString = Replace(sanitizedString, "[", "")
    sanitizedString = Replace(sanitizedString, "]", "")
    SanitizeSheetName = Left$(sanitizedString, 31)
End Function

Private Function GetOutputFilePath(ByVal strBasePath As String, ByVal strAffiliate As String) As String
    GetOutputFilePath = strBasePath & "\Demand Forecast - " & strAffiliate & " - " & Format$(Now, "ddmmyyyy_hhmmss") & ".xlsx"
End Function

Private Sub CleanupMemory()
    Set dictLifecycleMap = Nothing
    Set dictAffiliates = Nothing
    Set dictKeyFigures = Nothing
    Set dictHistoryCache = Nothing
    Erase arrStatusData
    Erase arrHistoryData
    Erase arrDemandData
End Sub

'================================================================================================
' 7. LOGGING & STATUS MAPPING
'================================================================================================

Private Sub InitializeLogSheet(ByVal ws As Worksheet)
    ws.Name = SHEET_LOG
    With ws.Range("A1:E1")
        .Value = Array("Timestamp", "Type", "Procedure", "Message", "Context / Error")
        .Font.Bold = True
    End With
    ws.Columns("A:E").AutoFit
End Sub

Private Sub WriteToLog(ByVal logType As LogType, ByVal procedureName As String, ByVal message As String, Optional ByVal errNumber As Long = 0, Optional ByVal errContext As String = "")
    If wsLog Is Nothing Then Exit Sub
    Dim nextRow As Long
    nextRow = wsLog.Cells(wsLog.Rows.Count, "A").End(xlUp).row + 1
    With wsLog.Rows(nextRow)
        .Cells(1).Value = Now()
        .Cells(2).Value = GetLogTypeString(logType)
        .Cells(3).Value = procedureName
        .Cells(4).Value = message
        If errNumber <> 0 Then
            .Cells(5).Value = "Err " & errNumber & ": " & errContext
        Else
            .Cells(5).Value = errContext
        End If
    End With
End Sub

Private Sub LogPerformance(ByRef tCheckpoint As Double, ByVal strStageName As String)
    WriteToLog ltProfile, strStageName, "Stage completed in " & Format$(Timer - tCheckpoint, "#,##0.00") & "s"
    tCheckpoint = Timer
End Sub

Private Function GetLogTypeString(ByVal logType As LogType) As String
    Select Case logType
        Case ltInfo: GetLogTypeString = "Info"
        Case ltWarning: GetLogTypeString = "Warning"
        Case ltError: GetLogTypeString = "Error"
        Case ltFatal: GetLogTypeString = "FATAL"
        Case ltProfile: GetLogTypeString = "Profile"
    End Select
End Function

Public Function GetStatusEnum(ByVal strStatus As String) As ProductStatus
    Dim strKey As String: strKey = UCase$(Trim$(strStatus))
    If dictStatusMap.Exists(strKey) Then
        GetStatusEnum = dictStatusMap.Item(strKey)
    Else
        GetStatusEnum = psUnknown
    End If
End Function

Public Function GetStatusString(ByVal enmStatus As ProductStatus) As String
    Select Case enmStatus
        Case psActive: GetStatusString = "Active"
        Case psPhaseInOut: GetStatusString = "PhaseIn-PhaseOut"
        Case psDiscontinued: GetStatusString = "Discontinued"
        Case psNew: GetStatusString = "New"
        Case Else: GetStatusString = "Unknown"
    End Select
End Function

Private Sub InitializeStatusMap()
    Set dictStatusMap = CreateObject("Scripting.Dictionary")
    dictStatusMap.CompareMode = vbTextCompare
    dictStatusMap.Add "ACTIVE", psActive
    dictStatusMap.Add "PHASEIN-PHASEOUT", psPhaseInOut
    dictStatusMap.Add "DISCONTINUED", psDiscontinued
    dictStatusMap.Add "NEW", psNew
End Sub
